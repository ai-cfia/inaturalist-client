# coding: utf-8

"""
iNaturalist API

# https://api.inaturalist.org/v1/  [iNaturalist](https://www.inaturalist.org/) is a global community of naturalists, scientists, and members of the public sharing over a million wildlife sightings to teach one another about the natural world while creating high quality citizen science data for science and conservation.  These API methods return data in JSON/JSONP and PNG response formats. They are meant to supplement the existing [iNaturalist API](https://www.inaturalist.org/pages/api+reference), implemented in Ruby on Rails, which has more functionality and supports more write operations, but tends to be slower and have less consistent response formats. Visit our [developers page](https://www.inaturalist.org/pages/developers) for more information. Write operations that expect and return JSON describe a single `body` parameter that represents the request body, which should be specified as JSON. See the \"Model\" of each body parameter for attributes that we accept in these JSON objects.  Multiple values for a single URL parameter should be separated by commas, e.g. `taxon_id=1,2,3`.  Map tiles are generated using the [node-mapnik](https://github.com/mapnik/node-mapnik) library, following the XYZ map tiling scheme. The \"Observation Tile\" methods accept nearly all the parameters of the observation search APIs, and will generate map tiles reflecting the same observations returned by searches. These \"Observation Tile\" methods have corresponding [UTFGrid](https://github.com/mapbox/utfgrid-spec) JSON responses which return information needed to make interactive maps.  Authentication in the Node API is handled via JSON Web Tokens (JWT). To obtain one, make an [OAuth-authenticated request](http://www.inaturalist.org/pages/api+reference#auth) to https://www.inaturalist.org/users/api_token. Each JWT will expire after 24 hours. Authentication required for all PUT and POST requests. Some GET requests will also include private information like hidden coordinates if the authenticated user has permission to view them.  Photos served from https://static.inaturalist.org and https://inaturalist-open-data.s3.amazonaws.com have multiple size variants and not all size variants are returned in responses. To access other sizes, the photo URL can be modified to replace only the size qualifier (each variant shares the exact same extension). The domain a photo is hosted under reflects the license under which the photo is being shared, and the domain may change over time if the license changes. Photos in the `inaturalist-open-data` domain are shared under open licenses. These can be accessed in bulk in the [iNaturalist AWS Open Dataset]( https://registry.opendata.aws/inaturalist-open-data/). Photos in the `static.inaturalist.org` domain do not have open licenses.  The available photo sizes are: * original (max 2048px in either dimension) * large (max 1024px in either dimension) * medium (max 500px in either dimension) * small (max 240px in either dimension) * thumb (max 100px in either dimension) * square (75px square)  iNaturalist Website: https://www.inaturalist.org/  Open Source Software: https://github.com/inaturalist/  ## Terms of Use  Use of this API is subject to the iNaturalist [Terms of Service](https://www.inaturalist.org/terms) and [Privacy Policy](https://www.inaturalist.org/privacy). We will block any use of our API that violates our Terms or Privacy Policy without notice. The API is intended to support application development, not data scraping. For pre- generated data exports, see https://www.inaturalist.org/pages/developers.  Please note that we throttle API usage to a max of 100 requests per minute, though we ask that you try to keep it to 60 requests per minute or lower, and to keep under 10,000 requests per day. If we notice usage that has serious impact on our performance we may institute blocks without notification.  Terms of Service: https://www.inaturalist.org/terms  Privacy Policy: https://www.inaturalist.org/privacy

The version of the OpenAPI document: 1.3.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from datetime import date, datetime
from typing import Any, Dict, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, validate_call
from typing_extensions import Annotated

from inaturalist_client.api_client import ApiClient, RequestSerialized
from inaturalist_client.api_response import ApiResponse
from inaturalist_client.models.utf_grid_response import UTFGridResponse
from inaturalist_client.rest import RESTResponseType


class UTFGridApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    async def colored_heatmap_zoom_xy_grid_json_get(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UTFGridResponse:
        """Colored Heatmap Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._colored_heatmap_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def colored_heatmap_zoom_xy_grid_json_get_with_http_info(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UTFGridResponse]:
        """Colored Heatmap Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._colored_heatmap_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def colored_heatmap_zoom_xy_grid_json_get_without_preload_content(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Colored Heatmap Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._colored_heatmap_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _colored_heatmap_zoom_xy_grid_json_get_serialize(
        self,
        zoom,
        x,
        y,
        color,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if zoom is not None:
            _path_params["zoom"] = zoom
        if x is not None:
            _path_params["x"] = x
        if y is not None:
            _path_params["y"] = y
        # process the query parameters
        if color is not None:
            _query_params.append(("color", color))

        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/colored_heatmap/{zoom}/{x}/{y}.grid.json",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def grid_zoom_xy_grid_json_get(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UTFGridResponse:
        """Grid Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._grid_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def grid_zoom_xy_grid_json_get_with_http_info(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UTFGridResponse]:
        """Grid Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._grid_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def grid_zoom_xy_grid_json_get_without_preload_content(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Grid Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._grid_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _grid_zoom_xy_grid_json_get_serialize(
        self,
        zoom,
        x,
        y,
        color,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if zoom is not None:
            _path_params["zoom"] = zoom
        if x is not None:
            _path_params["x"] = x
        if y is not None:
            _path_params["y"] = y
        # process the query parameters
        if color is not None:
            _query_params.append(("color", color))

        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/grid/{zoom}/{x}/{y}.grid.json",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def heatmap_zoom_xy_grid_json_get(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UTFGridResponse:
        """Heatmap Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._heatmap_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def heatmap_zoom_xy_grid_json_get_with_http_info(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UTFGridResponse]:
        """Heatmap Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._heatmap_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def heatmap_zoom_xy_grid_json_get_without_preload_content(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Heatmap Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._heatmap_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _heatmap_zoom_xy_grid_json_get_serialize(
        self,
        zoom,
        x,
        y,
        color,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if zoom is not None:
            _path_params["zoom"] = zoom
        if x is not None:
            _path_params["x"] = x
        if y is not None:
            _path_params["y"] = y
        # process the query parameters
        if color is not None:
            _query_params.append(("color", color))

        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/heatmap/{zoom}/{x}/{y}.grid.json",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def points_zoom_xy_grid_json_get(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UTFGridResponse:
        """Points Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._points_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def points_zoom_xy_grid_json_get_with_http_info(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UTFGridResponse]:
        """Points Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._points_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def points_zoom_xy_grid_json_get_without_preload_content(
        self,
        zoom: Annotated[
            int,
            Field(
                le=21,
                strict=True,
                ge=0,
                description="Zoom level. Z coordinate in the XYZ tiling scheme",
            ),
        ],
        x: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="X coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        y: Annotated[
            int,
            Field(
                strict=True,
                ge=0,
                description="Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom",
            ),
        ],
        color: Annotated[
            Optional[StrictStr],
            Field(
                description="Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`) "
            ),
        ] = None,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Points Tiles UTFGrid

        Given zero to many of following parameters, returns a JSON file following the UTFGrid spec, representing observations matching the search criteria

        :param zoom: Zoom level. Z coordinate in the XYZ tiling scheme (required)
        :type zoom: int
        :param x: X coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type x: int
        :param y: Y coordinate in the XYZ tiling scheme. Must be less than 2^zoom (required)
        :type y: int
        :param color: Primary color to use in tile creation. Accepts common colors by string (e.g. `color=blue`), and accepts escaped color HEX codes (e.g. `color=%2386a91c`)
        :type color: str
        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._points_zoom_xy_grid_json_get_serialize(
            zoom=zoom,
            x=x,
            y=y,
            color=color,
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UTFGridResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _points_zoom_xy_grid_json_get_serialize(
        self,
        zoom,
        x,
        y,
        color,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if zoom is not None:
            _path_params["zoom"] = zoom
        if x is not None:
            _path_params["x"] = x
        if y is not None:
            _path_params["y"] = y
        # process the query parameters
        if color is not None:
            _query_params.append(("color", color))

        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/points/{zoom}/{x}/{y}.grid.json",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
