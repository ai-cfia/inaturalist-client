# coding: utf-8

"""
iNaturalist API

# https://api.inaturalist.org/v1/  [iNaturalist](https://www.inaturalist.org/) is a global community of naturalists, scientists, and members of the public sharing over a million wildlife sightings to teach one another about the natural world while creating high quality citizen science data for science and conservation.  These API methods return data in JSON/JSONP and PNG response formats. They are meant to supplement the existing [iNaturalist API](https://www.inaturalist.org/pages/api+reference), implemented in Ruby on Rails, which has more functionality and supports more write operations, but tends to be slower and have less consistent response formats. Visit our [developers page](https://www.inaturalist.org/pages/developers) for more information. Write operations that expect and return JSON describe a single `body` parameter that represents the request body, which should be specified as JSON. See the \"Model\" of each body parameter for attributes that we accept in these JSON objects.  Multiple values for a single URL parameter should be separated by commas, e.g. `taxon_id=1,2,3`.  Map tiles are generated using the [node-mapnik](https://github.com/mapnik/node-mapnik) library, following the XYZ map tiling scheme. The \"Observation Tile\" methods accept nearly all the parameters of the observation search APIs, and will generate map tiles reflecting the same observations returned by searches. These \"Observation Tile\" methods have corresponding [UTFGrid](https://github.com/mapbox/utfgrid-spec) JSON responses which return information needed to make interactive maps.  Authentication in the Node API is handled via JSON Web Tokens (JWT). To obtain one, make an [OAuth-authenticated request](http://www.inaturalist.org/pages/api+reference#auth) to https://www.inaturalist.org/users/api_token. Each JWT will expire after 24 hours. Authentication required for all PUT and POST requests. Some GET requests will also include private information like hidden coordinates if the authenticated user has permission to view them.  Photos served from https://static.inaturalist.org and https://inaturalist-open-data.s3.amazonaws.com have multiple size variants and not all size variants are returned in responses. To access other sizes, the photo URL can be modified to replace only the size qualifier (each variant shares the exact same extension). The domain a photo is hosted under reflects the license under which the photo is being shared, and the domain may change over time if the license changes. Photos in the `inaturalist-open-data` domain are shared under open licenses. These can be accessed in bulk in the [iNaturalist AWS Open Dataset]( https://registry.opendata.aws/inaturalist-open-data/). Photos in the `static.inaturalist.org` domain do not have open licenses.  The available photo sizes are: * original (max 2048px in either dimension) * large (max 1024px in either dimension) * medium (max 500px in either dimension) * small (max 240px in either dimension) * thumb (max 100px in either dimension) * square (75px square)  iNaturalist Website: https://www.inaturalist.org/  Open Source Software: https://github.com/inaturalist/  ## Terms of Use  Use of this API is subject to the iNaturalist [Terms of Service](https://www.inaturalist.org/terms) and [Privacy Policy](https://www.inaturalist.org/privacy). We will block any use of our API that violates our Terms or Privacy Policy without notice. The API is intended to support application development, not data scraping. For pre- generated data exports, see https://www.inaturalist.org/pages/developers.  Please note that we throttle API usage to a max of 100 requests per minute, though we ask that you try to keep it to 60 requests per minute or lower, and to keep under 10,000 requests per day. If we notice usage that has serious impact on our performance we may institute blocks without notification.  Terms of Service: https://www.inaturalist.org/terms  Privacy Policy: https://www.inaturalist.org/privacy

The version of the OpenAPI document: 1.3.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

import warnings
from typing import Any, Dict, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, validate_call
from typing_extensions import Annotated

from inaturalist_client.api_client import ApiClient, RequestSerialized
from inaturalist_client.api_response import ApiResponse
from inaturalist_client.models.post_project_add import PostProjectAdd
from inaturalist_client.models.project_members_response import ProjectMembersResponse
from inaturalist_client.models.projects_response import ProjectsResponse
from inaturalist_client.rest import RESTResponseType


class ProjectsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    async def projects_autocomplete_get(
        self,
        q: Annotated[StrictStr, Field(description="Name must begin with this value")],
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be associated with this place"),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km "
            ),
        ] = None,
        featured: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked featured for the relevant site"),
        ] = None,
        noteworthy: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked noteworthy for the relevant site"),
        ] = None,
        site_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org "
            ),
        ] = None,
        rule_details: Annotated[
            Optional[StrictStr],
            Field(
                description="Return more information about project rules, for example return a full taxon object instead of simply an ID "
            ),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(description="Projects must be of this type"),
        ] = None,
        member_id: Annotated[
            Optional[StrictInt],
            Field(description="Project must have member with this user ID"),
        ] = None,
        has_params: Annotated[
            Optional[StrictBool],
            Field(description="Must have search parameter requirements"),
        ] = None,
        has_posts: Annotated[
            Optional[StrictBool], Field(description="Must have posts")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProjectsResponse:
        """Project Autocomplete

        Given an string, returns projects with titles starting with the search term

        :param q: Name must begin with this value (required)
        :type q: str
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param place_id: Must be associated with this place
        :type place_id: List[str]
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km
        :type radius: str
        :param featured: Must be marked featured for the relevant site
        :type featured: str
        :param noteworthy: Must be marked noteworthy for the relevant site
        :type noteworthy: str
        :param site_id: Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org
        :type site_id: int
        :param rule_details: Return more information about project rules, for example return a full taxon object instead of simply an ID
        :type rule_details: str
        :param type: Projects must be of this type
        :type type: List[str]
        :param member_id: Project must have member with this user ID
        :type member_id: int
        :param has_params: Must have search parameter requirements
        :type has_params: bool
        :param has_posts: Must have posts
        :type has_posts: bool
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_autocomplete_get_serialize(
            q=q,
            id=id,
            not_id=not_id,
            lat=lat,
            lng=lng,
            place_id=place_id,
            radius=radius,
            featured=featured,
            noteworthy=noteworthy,
            site_id=site_id,
            rule_details=rule_details,
            type=type,
            member_id=member_id,
            has_params=has_params,
            has_posts=has_posts,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_autocomplete_get_with_http_info(
        self,
        q: Annotated[StrictStr, Field(description="Name must begin with this value")],
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be associated with this place"),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km "
            ),
        ] = None,
        featured: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked featured for the relevant site"),
        ] = None,
        noteworthy: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked noteworthy for the relevant site"),
        ] = None,
        site_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org "
            ),
        ] = None,
        rule_details: Annotated[
            Optional[StrictStr],
            Field(
                description="Return more information about project rules, for example return a full taxon object instead of simply an ID "
            ),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(description="Projects must be of this type"),
        ] = None,
        member_id: Annotated[
            Optional[StrictInt],
            Field(description="Project must have member with this user ID"),
        ] = None,
        has_params: Annotated[
            Optional[StrictBool],
            Field(description="Must have search parameter requirements"),
        ] = None,
        has_posts: Annotated[
            Optional[StrictBool], Field(description="Must have posts")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProjectsResponse]:
        """Project Autocomplete

        Given an string, returns projects with titles starting with the search term

        :param q: Name must begin with this value (required)
        :type q: str
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param place_id: Must be associated with this place
        :type place_id: List[str]
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km
        :type radius: str
        :param featured: Must be marked featured for the relevant site
        :type featured: str
        :param noteworthy: Must be marked noteworthy for the relevant site
        :type noteworthy: str
        :param site_id: Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org
        :type site_id: int
        :param rule_details: Return more information about project rules, for example return a full taxon object instead of simply an ID
        :type rule_details: str
        :param type: Projects must be of this type
        :type type: List[str]
        :param member_id: Project must have member with this user ID
        :type member_id: int
        :param has_params: Must have search parameter requirements
        :type has_params: bool
        :param has_posts: Must have posts
        :type has_posts: bool
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_autocomplete_get_serialize(
            q=q,
            id=id,
            not_id=not_id,
            lat=lat,
            lng=lng,
            place_id=place_id,
            radius=radius,
            featured=featured,
            noteworthy=noteworthy,
            site_id=site_id,
            rule_details=rule_details,
            type=type,
            member_id=member_id,
            has_params=has_params,
            has_posts=has_posts,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_autocomplete_get_without_preload_content(
        self,
        q: Annotated[StrictStr, Field(description="Name must begin with this value")],
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be associated with this place"),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km "
            ),
        ] = None,
        featured: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked featured for the relevant site"),
        ] = None,
        noteworthy: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked noteworthy for the relevant site"),
        ] = None,
        site_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org "
            ),
        ] = None,
        rule_details: Annotated[
            Optional[StrictStr],
            Field(
                description="Return more information about project rules, for example return a full taxon object instead of simply an ID "
            ),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(description="Projects must be of this type"),
        ] = None,
        member_id: Annotated[
            Optional[StrictInt],
            Field(description="Project must have member with this user ID"),
        ] = None,
        has_params: Annotated[
            Optional[StrictBool],
            Field(description="Must have search parameter requirements"),
        ] = None,
        has_posts: Annotated[
            Optional[StrictBool], Field(description="Must have posts")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Project Autocomplete

        Given an string, returns projects with titles starting with the search term

        :param q: Name must begin with this value (required)
        :type q: str
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param place_id: Must be associated with this place
        :type place_id: List[str]
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km
        :type radius: str
        :param featured: Must be marked featured for the relevant site
        :type featured: str
        :param noteworthy: Must be marked noteworthy for the relevant site
        :type noteworthy: str
        :param site_id: Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org
        :type site_id: int
        :param rule_details: Return more information about project rules, for example return a full taxon object instead of simply an ID
        :type rule_details: str
        :param type: Projects must be of this type
        :type type: List[str]
        :param member_id: Project must have member with this user ID
        :type member_id: int
        :param has_params: Must have search parameter requirements
        :type has_params: bool
        :param has_posts: Must have posts
        :type has_posts: bool
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_autocomplete_get_serialize(
            q=q,
            id=id,
            not_id=not_id,
            lat=lat,
            lng=lng,
            place_id=place_id,
            radius=radius,
            featured=featured,
            noteworthy=noteworthy,
            site_id=site_id,
            rule_details=rule_details,
            type=type,
            member_id=member_id,
            has_params=has_params,
            has_posts=has_posts,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_autocomplete_get_serialize(
        self,
        q,
        id,
        not_id,
        lat,
        lng,
        place_id,
        radius,
        featured,
        noteworthy,
        site_id,
        rule_details,
        type,
        member_id,
        has_params,
        has_posts,
        per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "place_id": "csv",
            "type": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if q is not None:
            _query_params.append(("q", q))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if radius is not None:
            _query_params.append(("radius", radius))

        if featured is not None:
            _query_params.append(("featured", featured))

        if noteworthy is not None:
            _query_params.append(("noteworthy", noteworthy))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if rule_details is not None:
            _query_params.append(("rule_details", rule_details))

        if type is not None:
            _query_params.append(("type", type))

        if member_id is not None:
            _query_params.append(("member_id", member_id))

        if has_params is not None:
            _query_params.append(("has_params", has_params))

        if has_posts is not None:
            _query_params.append(("has_posts", has_posts))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/projects/autocomplete",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def projects_get(
        self,
        q: Annotated[
            Optional[StrictStr], Field(description="Name must begin with this value")
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be associated with this place"),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km "
            ),
        ] = None,
        featured: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked featured for the relevant site"),
        ] = None,
        noteworthy: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked noteworthy for the relevant site"),
        ] = None,
        site_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org "
            ),
        ] = None,
        rule_details: Annotated[
            Optional[StrictStr],
            Field(
                description="Return more information about project rules, for example return a full taxon object instead of simply an ID "
            ),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(description="Projects must be of this type"),
        ] = None,
        member_id: Annotated[
            Optional[StrictInt],
            Field(description="Project must have member with this user ID"),
        ] = None,
        has_params: Annotated[
            Optional[StrictBool],
            Field(description="Must have search parameter requirements"),
        ] = None,
        has_posts: Annotated[
            Optional[StrictBool], Field(description="Must have posts")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        order_by: Annotated[
            Optional[StrictStr], Field(description="Sort field")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProjectsResponse:
        """Project Search

        Given zero to many of following parameters, returns projects matching the search criteria

        :param q: Name must begin with this value
        :type q: str
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param place_id: Must be associated with this place
        :type place_id: List[str]
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km
        :type radius: str
        :param featured: Must be marked featured for the relevant site
        :type featured: str
        :param noteworthy: Must be marked noteworthy for the relevant site
        :type noteworthy: str
        :param site_id: Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org
        :type site_id: int
        :param rule_details: Return more information about project rules, for example return a full taxon object instead of simply an ID
        :type rule_details: str
        :param type: Projects must be of this type
        :type type: List[str]
        :param member_id: Project must have member with this user ID
        :type member_id: int
        :param has_params: Must have search parameter requirements
        :type has_params: bool
        :param has_posts: Must have posts
        :type has_posts: bool
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param order_by: Sort field
        :type order_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_get_serialize(
            q=q,
            id=id,
            not_id=not_id,
            lat=lat,
            lng=lng,
            place_id=place_id,
            radius=radius,
            featured=featured,
            noteworthy=noteworthy,
            site_id=site_id,
            rule_details=rule_details,
            type=type,
            member_id=member_id,
            has_params=has_params,
            has_posts=has_posts,
            per_page=per_page,
            order_by=order_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_get_with_http_info(
        self,
        q: Annotated[
            Optional[StrictStr], Field(description="Name must begin with this value")
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be associated with this place"),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km "
            ),
        ] = None,
        featured: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked featured for the relevant site"),
        ] = None,
        noteworthy: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked noteworthy for the relevant site"),
        ] = None,
        site_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org "
            ),
        ] = None,
        rule_details: Annotated[
            Optional[StrictStr],
            Field(
                description="Return more information about project rules, for example return a full taxon object instead of simply an ID "
            ),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(description="Projects must be of this type"),
        ] = None,
        member_id: Annotated[
            Optional[StrictInt],
            Field(description="Project must have member with this user ID"),
        ] = None,
        has_params: Annotated[
            Optional[StrictBool],
            Field(description="Must have search parameter requirements"),
        ] = None,
        has_posts: Annotated[
            Optional[StrictBool], Field(description="Must have posts")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        order_by: Annotated[
            Optional[StrictStr], Field(description="Sort field")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProjectsResponse]:
        """Project Search

        Given zero to many of following parameters, returns projects matching the search criteria

        :param q: Name must begin with this value
        :type q: str
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param place_id: Must be associated with this place
        :type place_id: List[str]
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km
        :type radius: str
        :param featured: Must be marked featured for the relevant site
        :type featured: str
        :param noteworthy: Must be marked noteworthy for the relevant site
        :type noteworthy: str
        :param site_id: Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org
        :type site_id: int
        :param rule_details: Return more information about project rules, for example return a full taxon object instead of simply an ID
        :type rule_details: str
        :param type: Projects must be of this type
        :type type: List[str]
        :param member_id: Project must have member with this user ID
        :type member_id: int
        :param has_params: Must have search parameter requirements
        :type has_params: bool
        :param has_posts: Must have posts
        :type has_posts: bool
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param order_by: Sort field
        :type order_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_get_serialize(
            q=q,
            id=id,
            not_id=not_id,
            lat=lat,
            lng=lng,
            place_id=place_id,
            radius=radius,
            featured=featured,
            noteworthy=noteworthy,
            site_id=site_id,
            rule_details=rule_details,
            type=type,
            member_id=member_id,
            has_params=has_params,
            has_posts=has_posts,
            per_page=per_page,
            order_by=order_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_get_without_preload_content(
        self,
        q: Annotated[
            Optional[StrictStr], Field(description="Name must begin with this value")
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be associated with this place"),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km "
            ),
        ] = None,
        featured: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked featured for the relevant site"),
        ] = None,
        noteworthy: Annotated[
            Optional[StrictStr],
            Field(description="Must be marked noteworthy for the relevant site"),
        ] = None,
        site_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org "
            ),
        ] = None,
        rule_details: Annotated[
            Optional[StrictStr],
            Field(
                description="Return more information about project rules, for example return a full taxon object instead of simply an ID "
            ),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(description="Projects must be of this type"),
        ] = None,
        member_id: Annotated[
            Optional[StrictInt],
            Field(description="Project must have member with this user ID"),
        ] = None,
        has_params: Annotated[
            Optional[StrictBool],
            Field(description="Must have search parameter requirements"),
        ] = None,
        has_posts: Annotated[
            Optional[StrictBool], Field(description="Must have posts")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        order_by: Annotated[
            Optional[StrictStr], Field(description="Sort field")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Project Search

        Given zero to many of following parameters, returns projects matching the search criteria

        :param q: Name must begin with this value
        :type q: str
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param place_id: Must be associated with this place
        :type place_id: List[str]
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius). Defaults to 500km
        :type radius: str
        :param featured: Must be marked featured for the relevant site
        :type featured: str
        :param noteworthy: Must be marked noteworthy for the relevant site
        :type noteworthy: str
        :param site_id: Site ID that applies to `featured` and `noteworthy`. Defaults to the site of the authenticated user, or to the main iNaturalist site https://www.inaturalist.org
        :type site_id: int
        :param rule_details: Return more information about project rules, for example return a full taxon object instead of simply an ID
        :type rule_details: str
        :param type: Projects must be of this type
        :type type: List[str]
        :param member_id: Project must have member with this user ID
        :type member_id: int
        :param has_params: Must have search parameter requirements
        :type has_params: bool
        :param has_posts: Must have posts
        :type has_posts: bool
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param order_by: Sort field
        :type order_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_get_serialize(
            q=q,
            id=id,
            not_id=not_id,
            lat=lat,
            lng=lng,
            place_id=place_id,
            radius=radius,
            featured=featured,
            noteworthy=noteworthy,
            site_id=site_id,
            rule_details=rule_details,
            type=type,
            member_id=member_id,
            has_params=has_params,
            has_posts=has_posts,
            per_page=per_page,
            order_by=order_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_get_serialize(
        self,
        q,
        id,
        not_id,
        lat,
        lng,
        place_id,
        radius,
        featured,
        noteworthy,
        site_id,
        rule_details,
        type,
        member_id,
        has_params,
        has_posts,
        per_page,
        order_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "place_id": "csv",
            "type": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if q is not None:
            _query_params.append(("q", q))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if radius is not None:
            _query_params.append(("radius", radius))

        if featured is not None:
            _query_params.append(("featured", featured))

        if noteworthy is not None:
            _query_params.append(("noteworthy", noteworthy))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if rule_details is not None:
            _query_params.append(("rule_details", rule_details))

        if type is not None:
            _query_params.append(("type", type))

        if member_id is not None:
            _query_params.append(("member_id", member_id))

        if has_params is not None:
            _query_params.append(("has_params", has_params))

        if has_posts is not None:
            _query_params.append(("has_posts", has_posts))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order_by is not None:
            _query_params.append(("order_by", order_by))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/projects",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def projects_id_add_post(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostProjectAdd], Field(description="ProjectObservation object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Project Add

        Add an observation to a project

        :param id: ID of the record (required)
        :type id: int
        :param body: ProjectObservation object
        :type body: PostProjectAdd
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_add_post_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_id_add_post_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostProjectAdd], Field(description="ProjectObservation object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Project Add

        Add an observation to a project

        :param id: ID of the record (required)
        :type id: int
        :param body: ProjectObservation object
        :type body: PostProjectAdd
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_add_post_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_id_add_post_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostProjectAdd], Field(description="ProjectObservation object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Project Add

        Add an observation to a project

        :param id: ID of the record (required)
        :type id: int
        :param body: ProjectObservation object
        :type body: PostProjectAdd
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_add_post_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_id_add_post_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/projects/{id}/add",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def projects_id_get(
        self,
        id: Annotated[List[StrictStr], Field(description="Must have this ID or slug")],
        rule_details: Annotated[
            Optional[StrictStr],
            Field(
                description="Return more information about project rules, for example return a full taxon object instead of simply an ID "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProjectsResponse:
        """Project Details

        Given an ID, or an array of IDs in comma-delimited format, returns corresponding projects. A maximum of 100 results will be returned

        :param id: Must have this ID or slug (required)
        :type id: List[str]
        :param rule_details: Return more information about project rules, for example return a full taxon object instead of simply an ID
        :type rule_details: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_get_serialize(
            id=id,
            rule_details=rule_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_id_get_with_http_info(
        self,
        id: Annotated[List[StrictStr], Field(description="Must have this ID or slug")],
        rule_details: Annotated[
            Optional[StrictStr],
            Field(
                description="Return more information about project rules, for example return a full taxon object instead of simply an ID "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProjectsResponse]:
        """Project Details

        Given an ID, or an array of IDs in comma-delimited format, returns corresponding projects. A maximum of 100 results will be returned

        :param id: Must have this ID or slug (required)
        :type id: List[str]
        :param rule_details: Return more information about project rules, for example return a full taxon object instead of simply an ID
        :type rule_details: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_get_serialize(
            id=id,
            rule_details=rule_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_id_get_without_preload_content(
        self,
        id: Annotated[List[StrictStr], Field(description="Must have this ID or slug")],
        rule_details: Annotated[
            Optional[StrictStr],
            Field(
                description="Return more information about project rules, for example return a full taxon object instead of simply an ID "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Project Details

        Given an ID, or an array of IDs in comma-delimited format, returns corresponding projects. A maximum of 100 results will be returned

        :param id: Must have this ID or slug (required)
        :type id: List[str]
        :param rule_details: Return more information about project rules, for example return a full taxon object instead of simply an ID
        :type rule_details: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_get_serialize(
            id=id,
            rule_details=rule_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_id_get_serialize(
        self,
        id,
        rule_details,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if rule_details is not None:
            _query_params.append(("rule_details", rule_details))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/projects/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def projects_id_join_post(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Projects Join

        Join a project

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_join_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_id_join_post_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Projects Join

        Join a project

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_join_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_id_join_post_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Projects Join

        Join a project

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_join_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_id_join_post_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/projects/{id}/join",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def projects_id_leave_delete(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Projects Leave

        Leave a project

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_leave_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_id_leave_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Projects Leave

        Leave a project

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_leave_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_id_leave_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Projects Leave

        Leave a project

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_leave_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_id_leave_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/projects/{id}/leave",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def projects_id_members_get(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        role: Annotated[
            Optional[StrictStr], Field(description="Membership role")
        ] = None,
        skip_counts: Annotated[
            Optional[StrictBool],
            Field(
                description="If counts are not needed, consider setting this to true to save on processing time, resulting in faster responses "
            ),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProjectMembersResponse:
        """Project Members

        Given an ID, return members of the project

        :param id: ID of the record (required)
        :type id: int
        :param role: Membership role
        :type role: str
        :param skip_counts: If counts are not needed, consider setting this to true to save on processing time, resulting in faster responses
        :type skip_counts: bool
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_members_get_serialize(
            id=id,
            role=role,
            skip_counts=skip_counts,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectMembersResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_id_members_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        role: Annotated[
            Optional[StrictStr], Field(description="Membership role")
        ] = None,
        skip_counts: Annotated[
            Optional[StrictBool],
            Field(
                description="If counts are not needed, consider setting this to true to save on processing time, resulting in faster responses "
            ),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProjectMembersResponse]:
        """Project Members

        Given an ID, return members of the project

        :param id: ID of the record (required)
        :type id: int
        :param role: Membership role
        :type role: str
        :param skip_counts: If counts are not needed, consider setting this to true to save on processing time, resulting in faster responses
        :type skip_counts: bool
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_members_get_serialize(
            id=id,
            role=role,
            skip_counts=skip_counts,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectMembersResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_id_members_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        role: Annotated[
            Optional[StrictStr], Field(description="Membership role")
        ] = None,
        skip_counts: Annotated[
            Optional[StrictBool],
            Field(
                description="If counts are not needed, consider setting this to true to save on processing time, resulting in faster responses "
            ),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Project Members

        Given an ID, return members of the project

        :param id: ID of the record (required)
        :type id: int
        :param role: Membership role
        :type role: str
        :param skip_counts: If counts are not needed, consider setting this to true to save on processing time, resulting in faster responses
        :type skip_counts: bool
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_members_get_serialize(
            id=id,
            role=role,
            skip_counts=skip_counts,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ProjectMembersResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_id_members_get_serialize(
        self,
        id,
        role,
        skip_counts,
        page,
        per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if role is not None:
            _query_params.append(("role", role))

        if skip_counts is not None:
            _query_params.append(("skip_counts", skip_counts))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/projects/{id}/members",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def projects_id_membership_get(
        self,
        id: Annotated[List[StrictInt], Field(description="Must have this ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Membership of current user

        Given an ID, or an array of IDs in comma-delimited format, return the details of the authenticated user's membership in these projects

        :param id: Must have this ID (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_membership_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_id_membership_get_with_http_info(
        self,
        id: Annotated[List[StrictInt], Field(description="Must have this ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Membership of current user

        Given an ID, or an array of IDs in comma-delimited format, return the details of the authenticated user's membership in these projects

        :param id: Must have this ID (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_membership_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_id_membership_get_without_preload_content(
        self,
        id: Annotated[List[StrictInt], Field(description="Must have this ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Membership of current user

        Given an ID, or an array of IDs in comma-delimited format, return the details of the authenticated user's membership in these projects

        :param id: Must have this ID (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_membership_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_id_membership_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/projects/{id}/membership",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def projects_id_remove_delete(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostProjectAdd], Field(description="ProjectObservation object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Project Add

        Remove an observation from a project

        :param id: ID of the record (required)
        :type id: int
        :param body: ProjectObservation object
        :type body: PostProjectAdd
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_remove_delete_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_id_remove_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostProjectAdd], Field(description="ProjectObservation object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Project Add

        Remove an observation from a project

        :param id: ID of the record (required)
        :type id: int
        :param body: ProjectObservation object
        :type body: PostProjectAdd
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_remove_delete_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_id_remove_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostProjectAdd], Field(description="ProjectObservation object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Project Add

        Remove an observation from a project

        :param id: ID of the record (required)
        :type id: int
        :param body: ProjectObservation object
        :type body: PostProjectAdd
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._projects_id_remove_delete_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_id_remove_delete_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/projects/{id}/remove",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def projects_id_subscriptions_get(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) Project Subscriptions

        [Deprecated] Subscriptions to projects are managed through joining and leaving projects, so this will not return any useful information.  Given an ID, return subscription of the current user

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501
        warnings.warn(
            "GET /projects/{id}/subscriptions is deprecated.", DeprecationWarning
        )

        _param = self._projects_id_subscriptions_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def projects_id_subscriptions_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) Project Subscriptions

        [Deprecated] Subscriptions to projects are managed through joining and leaving projects, so this will not return any useful information.  Given an ID, return subscription of the current user

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501
        warnings.warn(
            "GET /projects/{id}/subscriptions is deprecated.", DeprecationWarning
        )

        _param = self._projects_id_subscriptions_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def projects_id_subscriptions_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Project Subscriptions

        [Deprecated] Subscriptions to projects are managed through joining and leaving projects, so this will not return any useful information.  Given an ID, return subscription of the current user

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501
        warnings.warn(
            "GET /projects/{id}/subscriptions is deprecated.", DeprecationWarning
        )

        _param = self._projects_id_subscriptions_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _projects_id_subscriptions_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/projects/{id}/subscriptions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def subscriptions_project_id_subscribe_post(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Project Subscribe

        Toggles current user's subscription to this project. If the logged-in user is not subscribed, POSTing here will subscribe them. If they are already subscribed, this will remove the subscription

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._subscriptions_project_id_subscribe_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def subscriptions_project_id_subscribe_post_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Project Subscribe

        Toggles current user's subscription to this project. If the logged-in user is not subscribed, POSTing here will subscribe them. If they are already subscribed, this will remove the subscription

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._subscriptions_project_id_subscribe_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def subscriptions_project_id_subscribe_post_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Project Subscribe

        Toggles current user's subscription to this project. If the logged-in user is not subscribed, POSTing here will subscribe them. If they are already subscribed, this will remove the subscription

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._subscriptions_project_id_subscribe_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _subscriptions_project_id_subscribe_post_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/subscriptions/project/{id}/subscribe",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
