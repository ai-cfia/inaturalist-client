# coding: utf-8

"""
iNaturalist API

# https://api.inaturalist.org/v1/  [iNaturalist](https://www.inaturalist.org/) is a global community of naturalists, scientists, and members of the public sharing over a million wildlife sightings to teach one another about the natural world while creating high quality citizen science data for science and conservation.  These API methods return data in JSON/JSONP and PNG response formats. They are meant to supplement the existing [iNaturalist API](https://www.inaturalist.org/pages/api+reference), implemented in Ruby on Rails, which has more functionality and supports more write operations, but tends to be slower and have less consistent response formats. Visit our [developers page](https://www.inaturalist.org/pages/developers) for more information. Write operations that expect and return JSON describe a single `body` parameter that represents the request body, which should be specified as JSON. See the \"Model\" of each body parameter for attributes that we accept in these JSON objects.  Multiple values for a single URL parameter should be separated by commas, e.g. `taxon_id=1,2,3`.  Map tiles are generated using the [node-mapnik](https://github.com/mapnik/node-mapnik) library, following the XYZ map tiling scheme. The \"Observation Tile\" methods accept nearly all the parameters of the observation search APIs, and will generate map tiles reflecting the same observations returned by searches. These \"Observation Tile\" methods have corresponding [UTFGrid](https://github.com/mapbox/utfgrid-spec) JSON responses which return information needed to make interactive maps.  Authentication in the Node API is handled via JSON Web Tokens (JWT). To obtain one, make an [OAuth-authenticated request](http://www.inaturalist.org/pages/api+reference#auth) to https://www.inaturalist.org/users/api_token. Each JWT will expire after 24 hours. Authentication required for all PUT and POST requests. Some GET requests will also include private information like hidden coordinates if the authenticated user has permission to view them.  Photos served from https://static.inaturalist.org and https://inaturalist-open-data.s3.amazonaws.com have multiple size variants and not all size variants are returned in responses. To access other sizes, the photo URL can be modified to replace only the size qualifier (each variant shares the exact same extension). The domain a photo is hosted under reflects the license under which the photo is being shared, and the domain may change over time if the license changes. Photos in the `inaturalist-open-data` domain are shared under open licenses. These can be accessed in bulk in the [iNaturalist AWS Open Dataset]( https://registry.opendata.aws/inaturalist-open-data/). Photos in the `static.inaturalist.org` domain do not have open licenses.  The available photo sizes are: * original (max 2048px in either dimension) * large (max 1024px in either dimension) * medium (max 500px in either dimension) * small (max 240px in either dimension) * thumb (max 100px in either dimension) * square (75px square)  iNaturalist Website: https://www.inaturalist.org/  Open Source Software: https://github.com/inaturalist/  ## Terms of Use  Use of this API is subject to the iNaturalist [Terms of Service](https://www.inaturalist.org/terms) and [Privacy Policy](https://www.inaturalist.org/privacy). We will block any use of our API that violates our Terms or Privacy Policy without notice. The API is intended to support application development, not data scraping. For pre- generated data exports, see https://www.inaturalist.org/pages/developers.  Please note that we throttle API usage to a max of 100 requests per minute, though we ask that you try to keep it to 60 requests per minute or lower, and to keep under 10,000 requests per day. If we notice usage that has serious impact on our performance we may institute blocks without notification.  Terms of Service: https://www.inaturalist.org/terms  Privacy Policy: https://www.inaturalist.org/privacy

The version of the OpenAPI document: 1.3.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from datetime import date, datetime
from typing import Any, Dict, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, validate_call
from typing_extensions import Annotated

from inaturalist_client.api_client import ApiClient, RequestSerialized
from inaturalist_client.api_response import ApiResponse
from inaturalist_client.models.observations_observers_response import (
    ObservationsObserversResponse,
)
from inaturalist_client.models.observations_response import ObservationsResponse
from inaturalist_client.models.observations_show_response import (
    ObservationsShowResponse,
)
from inaturalist_client.models.post_observation import PostObservation
from inaturalist_client.models.post_observation_vote import PostObservationVote
from inaturalist_client.models.post_quality import PostQuality
from inaturalist_client.models.species_counts_response import SpeciesCountsResponse
from inaturalist_client.models.user_counts_response import UserCountsResponse
from inaturalist_client.rest import RESTResponseType


class ObservationsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    async def observations_deleted_get(
        self,
        since: Annotated[datetime, Field(description="Deleted at or after this time")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observations Deleted

        Given a starting date, return an array of IDs of the authenticated user's observations that have been deleted since that date. Requires authentication

        :param since: Deleted at or after this time (required)
        :type since: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_deleted_get_serialize(
            since=since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_deleted_get_with_http_info(
        self,
        since: Annotated[datetime, Field(description="Deleted at or after this time")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observations Deleted

        Given a starting date, return an array of IDs of the authenticated user's observations that have been deleted since that date. Requires authentication

        :param since: Deleted at or after this time (required)
        :type since: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_deleted_get_serialize(
            since=since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_deleted_get_without_preload_content(
        self,
        since: Annotated[datetime, Field(description="Deleted at or after this time")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observations Deleted

        Given a starting date, return an array of IDs of the authenticated user's observations that have been deleted since that date. Requires authentication

        :param since: Deleted at or after this time (required)
        :type since: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_deleted_get_serialize(
            since=since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_deleted_get_serialize(
        self,
        since,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if since is not None:
            if isinstance(since, datetime):
                _query_params.append(
                    (
                        "since",
                        since.strftime(self.api_client.configuration.datetime_format),
                    )
                )
            else:
                _query_params.append(("since", since))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/deleted",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_get(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sort order")] = None,
        order_by: Annotated[
            Optional[StrictStr], Field(description="Sort field")
        ] = None,
        only_id: Annotated[
            Optional[StrictBool], Field(description="Return only the record IDs")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObservationsResponse:
        """Observation Search

        Given zero to many of following parameters, returns observations matching the search criteria. The large size of the observations index prevents us from supporting the `page` parameter when retrieving records from large result sets. If you need to retrieve large numbers of records, use the `per_page` and `id_above` or `id_below` parameters instead.

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param order: Sort order
        :type order: str
        :param order_by: Sort field
        :type order_by: str
        :param only_id: Return only the record IDs
        :type only_id: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            page=page,
            per_page=per_page,
            order=order,
            order_by=order_by,
            only_id=only_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ObservationsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_get_with_http_info(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sort order")] = None,
        order_by: Annotated[
            Optional[StrictStr], Field(description="Sort field")
        ] = None,
        only_id: Annotated[
            Optional[StrictBool], Field(description="Return only the record IDs")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObservationsResponse]:
        """Observation Search

        Given zero to many of following parameters, returns observations matching the search criteria. The large size of the observations index prevents us from supporting the `page` parameter when retrieving records from large result sets. If you need to retrieve large numbers of records, use the `per_page` and `id_above` or `id_below` parameters instead.

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param order: Sort order
        :type order: str
        :param order_by: Sort field
        :type order_by: str
        :param only_id: Return only the record IDs
        :type only_id: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            page=page,
            per_page=per_page,
            order=order,
            order_by=order_by,
            only_id=only_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ObservationsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_get_without_preload_content(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sort order")] = None,
        order_by: Annotated[
            Optional[StrictStr], Field(description="Sort field")
        ] = None,
        only_id: Annotated[
            Optional[StrictBool], Field(description="Return only the record IDs")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Search

        Given zero to many of following parameters, returns observations matching the search criteria. The large size of the observations index prevents us from supporting the `page` parameter when retrieving records from large result sets. If you need to retrieve large numbers of records, use the `per_page` and `id_above` or `id_below` parameters instead.

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param order: Sort order
        :type order: str
        :param order_by: Sort field
        :type order_by: str
        :param only_id: Return only the record IDs
        :type only_id: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            page=page,
            per_page=per_page,
            order=order,
            order_by=order_by,
            only_id=only_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ObservationsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_get_serialize(
        self,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        locale,
        preferred_place_id,
        ttl,
        page,
        per_page,
        order,
        order_by,
        only_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        if locale is not None:
            _query_params.append(("locale", locale))

        if preferred_place_id is not None:
            _query_params.append(("preferred_place_id", preferred_place_id))

        if ttl is not None:
            _query_params.append(("ttl", ttl))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if order_by is not None:
            _query_params.append(("order_by", order_by))

        if only_id is not None:
            _query_params.append(("only_id", only_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_histogram_get(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        date_field: Annotated[
            Optional[StrictStr],
            Field(
                description="Histogram basis: when the observation was created or observed "
            ),
        ] = None,
        interval: Annotated[
            Optional[StrictStr],
            Field(
                description="Time interval for histogram, with groups starting on or contained within the group value. The year, month, week, day, and hour options will set default values for `d1` or `created_d1` depending on the value of `date_field`, to limit the number of groups returned. You can override those values if you want data from a longer or shorter time span. The `hour` interval only works with `date_field=created`, and this you should filter dates with `created_d[1,2]` "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Histogram

        Given zero to many of following parameters, returns histogram data about observations matching the search criteria

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param date_field: Histogram basis: when the observation was created or observed
        :type date_field: str
        :param interval: Time interval for histogram, with groups starting on or contained within the group value. The year, month, week, day, and hour options will set default values for `d1` or `created_d1` depending on the value of `date_field`, to limit the number of groups returned. You can override those values if you want data from a longer or shorter time span. The `hour` interval only works with `date_field=created`, and this you should filter dates with `created_d[1,2]`
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_histogram_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            date_field=date_field,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_histogram_get_with_http_info(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        date_field: Annotated[
            Optional[StrictStr],
            Field(
                description="Histogram basis: when the observation was created or observed "
            ),
        ] = None,
        interval: Annotated[
            Optional[StrictStr],
            Field(
                description="Time interval for histogram, with groups starting on or contained within the group value. The year, month, week, day, and hour options will set default values for `d1` or `created_d1` depending on the value of `date_field`, to limit the number of groups returned. You can override those values if you want data from a longer or shorter time span. The `hour` interval only works with `date_field=created`, and this you should filter dates with `created_d[1,2]` "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Histogram

        Given zero to many of following parameters, returns histogram data about observations matching the search criteria

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param date_field: Histogram basis: when the observation was created or observed
        :type date_field: str
        :param interval: Time interval for histogram, with groups starting on or contained within the group value. The year, month, week, day, and hour options will set default values for `d1` or `created_d1` depending on the value of `date_field`, to limit the number of groups returned. You can override those values if you want data from a longer or shorter time span. The `hour` interval only works with `date_field=created`, and this you should filter dates with `created_d[1,2]`
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_histogram_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            date_field=date_field,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_histogram_get_without_preload_content(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        date_field: Annotated[
            Optional[StrictStr],
            Field(
                description="Histogram basis: when the observation was created or observed "
            ),
        ] = None,
        interval: Annotated[
            Optional[StrictStr],
            Field(
                description="Time interval for histogram, with groups starting on or contained within the group value. The year, month, week, day, and hour options will set default values for `d1` or `created_d1` depending on the value of `date_field`, to limit the number of groups returned. You can override those values if you want data from a longer or shorter time span. The `hour` interval only works with `date_field=created`, and this you should filter dates with `created_d[1,2]` "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Histogram

        Given zero to many of following parameters, returns histogram data about observations matching the search criteria

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param date_field: Histogram basis: when the observation was created or observed
        :type date_field: str
        :param interval: Time interval for histogram, with groups starting on or contained within the group value. The year, month, week, day, and hour options will set default values for `d1` or `created_d1` depending on the value of `date_field`, to limit the number of groups returned. You can override those values if you want data from a longer or shorter time span. The `hour` interval only works with `date_field=created`, and this you should filter dates with `created_d[1,2]`
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_histogram_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            date_field=date_field,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_histogram_get_serialize(
        self,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        locale,
        preferred_place_id,
        ttl,
        date_field,
        interval,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        if locale is not None:
            _query_params.append(("locale", locale))

        if preferred_place_id is not None:
            _query_params.append(("preferred_place_id", preferred_place_id))

        if ttl is not None:
            _query_params.append(("ttl", ttl))

        if date_field is not None:
            _query_params.append(("date_field", date_field))

        if interval is not None:
            _query_params.append(("interval", interval))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/histogram",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_delete(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Delete

        Delete an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Delete

        Delete an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Delete

        Delete an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/observations/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_fave_post(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observations Fave

        Fave an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_fave_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_fave_post_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observations Fave

        Fave an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_fave_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_fave_post_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observations Fave

        Fave an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_fave_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_fave_post_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/observations/{id}/fave",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_get(
        self,
        id: Annotated[List[StrictInt], Field(description="Must have this ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObservationsShowResponse:
        """Observation Details

        Given an ID, or an array of IDs in comma-delimited format, returns corresponding observations. A maximum of 200 results will be returned

        :param id: Must have this ID (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ObservationsShowResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_get_with_http_info(
        self,
        id: Annotated[List[StrictInt], Field(description="Must have this ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObservationsShowResponse]:
        """Observation Details

        Given an ID, or an array of IDs in comma-delimited format, returns corresponding observations. A maximum of 200 results will be returned

        :param id: Must have this ID (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ObservationsShowResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_get_without_preload_content(
        self,
        id: Annotated[List[StrictInt], Field(description="Must have this ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Details

        Given an ID, or an array of IDs in comma-delimited format, returns corresponding observations. A maximum of 200 results will be returned

        :param id: Must have this ID (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ObservationsShowResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_put(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostObservation], Field(description="Comment object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Update

        Update an observation

        :param id: ID of the record (required)
        :type id: int
        :param body: Comment object
        :type body: PostObservation
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_put_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_put_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostObservation], Field(description="Comment object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Update

        Update an observation

        :param id: ID of the record (required)
        :type id: int
        :param body: Comment object
        :type body: PostObservation
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_put_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_put_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostObservation], Field(description="Comment object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Update

        Update an observation

        :param id: ID of the record (required)
        :type id: int
        :param body: Comment object
        :type body: PostObservation
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_put_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_put_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/observations/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_quality_metric_delete(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        metric: Annotated[StrictStr, Field(description="Data quality category")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Quality Metric Delete

        Delete a quality metric

        :param id: ID of the record (required)
        :type id: int
        :param metric: Data quality category (required)
        :type metric: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_quality_metric_delete_serialize(
            id=id,
            metric=metric,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_quality_metric_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        metric: Annotated[StrictStr, Field(description="Data quality category")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Quality Metric Delete

        Delete a quality metric

        :param id: ID of the record (required)
        :type id: int
        :param metric: Data quality category (required)
        :type metric: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_quality_metric_delete_serialize(
            id=id,
            metric=metric,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_quality_metric_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        metric: Annotated[StrictStr, Field(description="Data quality category")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Quality Metric Delete

        Delete a quality metric

        :param id: ID of the record (required)
        :type id: int
        :param metric: Data quality category (required)
        :type metric: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_quality_metric_delete_serialize(
            id=id,
            metric=metric,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_quality_metric_delete_serialize(
        self,
        id,
        metric,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        if metric is not None:
            _path_params["metric"] = metric
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/observations/{id}/quality/{metric}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_quality_metric_post(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        metric: Annotated[StrictStr, Field(description="Data quality category")],
        body: Annotated[
            Optional[PostQuality], Field(description="Quality object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Quality Metric Set

        Set the value of a quality metric

        :param id: ID of the record (required)
        :type id: int
        :param metric: Data quality category (required)
        :type metric: str
        :param body: Quality object
        :type body: PostQuality
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_quality_metric_post_serialize(
            id=id,
            metric=metric,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_quality_metric_post_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        metric: Annotated[StrictStr, Field(description="Data quality category")],
        body: Annotated[
            Optional[PostQuality], Field(description="Quality object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Quality Metric Set

        Set the value of a quality metric

        :param id: ID of the record (required)
        :type id: int
        :param metric: Data quality category (required)
        :type metric: str
        :param body: Quality object
        :type body: PostQuality
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_quality_metric_post_serialize(
            id=id,
            metric=metric,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_quality_metric_post_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        metric: Annotated[StrictStr, Field(description="Data quality category")],
        body: Annotated[
            Optional[PostQuality], Field(description="Quality object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Quality Metric Set

        Set the value of a quality metric

        :param id: ID of the record (required)
        :type id: int
        :param metric: Data quality category (required)
        :type metric: str
        :param body: Quality object
        :type body: PostQuality
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_quality_metric_post_serialize(
            id=id,
            metric=metric,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_quality_metric_post_serialize(
        self,
        id,
        metric,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        if metric is not None:
            _path_params["metric"] = metric
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/observations/{id}/quality/{metric}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_review_post(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observations Review

        Review an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_review_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_review_post_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observations Review

        Review an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_review_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_review_post_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observations Review

        Review an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_review_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_review_post_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/observations/{id}/review",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_subscriptions_get(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Subscriptions

        Fetches any subscriptions the current user has to this observation or the observer

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_subscriptions_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_subscriptions_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Subscriptions

        Fetches any subscriptions the current user has to this observation or the observer

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_subscriptions_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_subscriptions_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Subscriptions

        Fetches any subscriptions the current user has to this observation or the observer

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_subscriptions_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_subscriptions_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/{id}/subscriptions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_taxon_summary_get(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Taxon Summary

        Fetches information about this observation's taxon, within the context of this observation's location

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_taxon_summary_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_taxon_summary_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Taxon Summary

        Fetches information about this observation's taxon, within the context of this observation's location

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_taxon_summary_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_taxon_summary_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Taxon Summary

        Fetches information about this observation's taxon, within the context of this observation's location

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_taxon_summary_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_taxon_summary_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/{id}/taxon_summary",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_unfave_delete(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observations Unfave

        Unfave an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_unfave_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_unfave_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observations Unfave

        Unfave an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_unfave_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_unfave_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observations Unfave

        Unfave an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_unfave_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_unfave_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/observations/{id}/unfave",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_unreview_post(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observations Unreview

        Unreview an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_unreview_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_unreview_post_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observations Unreview

        Unreview an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_unreview_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_unreview_post_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observations Unreview

        Unreview an observation

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_unreview_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_unreview_post_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/observations/{id}/unreview",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_id_viewed_updates_put(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Field Value Update

        Mark all updates associated with this observation as viewed by logged-in user

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_viewed_updates_put_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_id_viewed_updates_put_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Field Value Update

        Mark all updates associated with this observation as viewed by logged-in user

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_viewed_updates_put_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_id_viewed_updates_put_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Field Value Update

        Mark all updates associated with this observation as viewed by logged-in user

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_id_viewed_updates_put_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_id_viewed_updates_put_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/observations/{id}/viewed_updates",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_identifiers_get(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UserCountsResponse:
        """Observation Identifiers

        Given zero to many of following parameters, returns identifiers of observations matching the search criteria and the count of observations they have identified, ordered by count descending. A maximum of 500 results will be returned

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_identifiers_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UserCountsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_identifiers_get_with_http_info(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UserCountsResponse]:
        """Observation Identifiers

        Given zero to many of following parameters, returns identifiers of observations matching the search criteria and the count of observations they have identified, ordered by count descending. A maximum of 500 results will be returned

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_identifiers_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UserCountsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_identifiers_get_without_preload_content(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Identifiers

        Given zero to many of following parameters, returns identifiers of observations matching the search criteria and the count of observations they have identified, ordered by count descending. A maximum of 500 results will be returned

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_identifiers_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UserCountsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_identifiers_get_serialize(
        self,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        locale,
        preferred_place_id,
        ttl,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        if locale is not None:
            _query_params.append(("locale", locale))

        if preferred_place_id is not None:
            _query_params.append(("preferred_place_id", preferred_place_id))

        if ttl is not None:
            _query_params.append(("ttl", ttl))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/identifiers",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_observers_get(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObservationsObserversResponse:
        """Observation Observers

        Given zero to many of following parameters, returns observers of observations matching the search criteria and the count of observations and distinct taxa of rank `species` they have observed. A maximum of 500 results will be returned

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_observers_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ObservationsObserversResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_observers_get_with_http_info(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObservationsObserversResponse]:
        """Observation Observers

        Given zero to many of following parameters, returns observers of observations matching the search criteria and the count of observations and distinct taxa of rank `species` they have observed. A maximum of 500 results will be returned

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_observers_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ObservationsObserversResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_observers_get_without_preload_content(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Observers

        Given zero to many of following parameters, returns observers of observations matching the search criteria and the count of observations and distinct taxa of rank `species` they have observed. A maximum of 500 results will be returned

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_observers_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ObservationsObserversResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_observers_get_serialize(
        self,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        locale,
        preferred_place_id,
        ttl,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        if locale is not None:
            _query_params.append(("locale", locale))

        if preferred_place_id is not None:
            _query_params.append(("preferred_place_id", preferred_place_id))

        if ttl is not None:
            _query_params.append(("ttl", ttl))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/observers",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_popular_field_values_get(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Popular Field Values

        Given zero to many of following parameters, returns an array of relevant controlled terms values and a monthly histogram

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_popular_field_values_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_popular_field_values_get_with_http_info(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Popular Field Values

        Given zero to many of following parameters, returns an array of relevant controlled terms values and a monthly histogram

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_popular_field_values_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_popular_field_values_get_without_preload_content(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Popular Field Values

        Given zero to many of following parameters, returns an array of relevant controlled terms values and a monthly histogram

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_popular_field_values_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_popular_field_values_get_serialize(
        self,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        locale,
        preferred_place_id,
        ttl,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        if locale is not None:
            _query_params.append(("locale", locale))

        if preferred_place_id is not None:
            _query_params.append(("preferred_place_id", preferred_place_id))

        if ttl is not None:
            _query_params.append(("ttl", ttl))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/popular_field_values",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_post(
        self,
        body: Annotated[
            Optional[PostObservation], Field(description="Comment object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Create

        Create an observation

        :param body: Comment object
        :type body: PostObservation
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_post_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_post_with_http_info(
        self,
        body: Annotated[
            Optional[PostObservation], Field(description="Comment object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Create

        Create an observation

        :param body: Comment object
        :type body: PostObservation
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_post_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_post_without_preload_content(
        self,
        body: Annotated[
            Optional[PostObservation], Field(description="Comment object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Create

        Create an observation

        :param body: Comment object
        :type body: PostObservation
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_post_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_post_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/observations",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_species_counts_get(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        include_ancestors: Annotated[
            Optional[StrictBool],
            Field(description="Include taxon ancestors in the response"),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is 500 "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpeciesCountsResponse:
        """Observation Species Counts

        Given zero to many of following parameters, returns `leaf taxa` associated with observations matching the search criteria and the count of observations they are associated with, ordered by count descending. `Leaf taxa` are the leaves of the taxonomic tree containing only the taxa associated with observations matching the search criteria.

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param include_ancestors: Include taxon ancestors in the response
        :type include_ancestors: bool
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is 500
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_species_counts_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            include_ancestors=include_ancestors,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SpeciesCountsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_species_counts_get_with_http_info(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        include_ancestors: Annotated[
            Optional[StrictBool],
            Field(description="Include taxon ancestors in the response"),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is 500 "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpeciesCountsResponse]:
        """Observation Species Counts

        Given zero to many of following parameters, returns `leaf taxa` associated with observations matching the search criteria and the count of observations they are associated with, ordered by count descending. `Leaf taxa` are the leaves of the taxonomic tree containing only the taxa associated with observations matching the search criteria.

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param include_ancestors: Include taxon ancestors in the response
        :type include_ancestors: bool
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is 500
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_species_counts_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            include_ancestors=include_ancestors,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SpeciesCountsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_species_counts_get_without_preload_content(
        self,
        acc: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not positional accuracy / coordinate uncertainty has been specified"
            ),
        ] = None,
        captive: Annotated[
            Optional[StrictBool],
            Field(description="Captive or cultivated observations"),
        ] = None,
        endemic: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are endemic to their location"),
        ] = None,
        geo: Annotated[
            Optional[StrictBool],
            Field(description="Observations that are georeferenced"),
        ] = None,
        id_please: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used."
            ),
        ] = None,
        identified: Annotated[
            Optional[StrictBool],
            Field(description="Observations that have community identifications"),
        ] = None,
        introduced: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are introduced in their location "
            ),
        ] = None,
        mappable: Annotated[
            Optional[StrictBool],
            Field(description="Observations that show on map tiles"),
        ] = None,
        native: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are native to their location"),
        ] = None,
        out_of_range: Annotated[
            Optional[StrictBool],
            Field(description="Observations whose taxa are outside their known ranges"),
        ] = None,
        pcid: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s) "
            ),
        ] = None,
        photos: Annotated[
            Optional[StrictBool], Field(description="Observations with photos")
        ] = None,
        popular: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations that have been favorited by at least one user "
            ),
        ] = None,
        sounds: Annotated[
            Optional[StrictBool], Field(description="Observations with sounds")
        ] = None,
        taxon_is_active: Annotated[
            Optional[StrictBool],
            Field(description="Observations of active taxon concepts "),
        ] = None,
        threatened: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations whose taxa are threatened in their location "
            ),
        ] = None,
        verifiable: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research` "
            ),
        ] = None,
        licensed: Annotated[
            Optional[StrictBool],
            Field(description="License attribute of an observation must not be null"),
        ] = None,
        photo_licensed: Annotated[
            Optional[StrictBool],
            Field(
                description="License attribute of at least one photo of an observation must not be null"
            ),
        ] = None,
        expected_nearby: Annotated[
            Optional[StrictBool],
            Field(description="Observation taxon is expected nearby"),
        ] = None,
        id: Annotated[
            Optional[List[StrictStr]], Field(description="Must have this ID")
        ] = None,
        not_id: Annotated[
            Optional[List[StrictStr]], Field(description="Must not have this ID")
        ] = None,
        license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Observation must have this license"),
        ] = None,
        ofv_datatype: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have an observation field value with this datatype"
            ),
        ] = None,
        photo_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one photo with this license"),
        ] = None,
        place_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must be observed within the place with this ID"),
        ] = None,
        project_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be added to the project this ID or slug"),
        ] = None,
        rank: Annotated[
            Optional[List[StrictStr]], Field(description="Taxon must have this rank")
        ] = None,
        site_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must be affiliated with the iNaturalist network website with this ID "
            ),
        ] = None,
        sound_license: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have at least one sound with this license"),
        ] = None,
        taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Only show observations of these taxa and their descendants"
            ),
        ] = None,
        without_taxon_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Exclude observations of these taxa and their descendants"
            ),
        ] = None,
        taxon_name: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have a scientific or common name matching this string "
            ),
        ] = None,
        user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="User must have this ID or login"),
        ] = None,
        user_login: Annotated[
            Optional[List[StrictStr]], Field(description="User must have this login")
        ] = None,
        ident_user_id: Annotated[
            Optional[StrictInt],
            Field(description="Observations identified by a particular user"),
        ] = None,
        hour: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this hour of the day"),
        ] = None,
        day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this day of the month"),
        ] = None,
        month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this month"),
        ] = None,
        year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be observed within this year"),
        ] = None,
        created_day: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this day of the month"),
        ] = None,
        created_month: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this month"),
        ] = None,
        created_year: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must be created within this year"),
        ] = None,
        term_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must have an annotation using this controlled term ID"),
        ] = None,
        term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        without_term_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Exclude observations with annotations using this controlled value ID. "
            ),
        ] = None,
        without_term_value_id: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter "
            ),
        ] = None,
        term_id_or_unknown: Annotated[
            Optional[List[StrictInt]],
            Field(
                description="Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation. "
            ),
        ] = None,
        annotation_user_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have an annotation created by this user "),
        ] = None,
        acc_above: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy above this value (meters)"
            ),
        ] = None,
        acc_below: Annotated[
            Optional[StrictStr],
            Field(
                description="Must have a positional accuracy below this value (meters)"
            ),
        ] = None,
        acc_below_or_unknown: Annotated[
            Optional[StrictStr],
            Field(
                description="Positional accuracy must be below this value (in meters) or be unknown"
            ),
        ] = None,
        d1: Annotated[
            Optional[date], Field(description="Must be observed on or after this date")
        ] = None,
        d2: Annotated[
            Optional[date], Field(description="Must be observed on or before this date")
        ] = None,
        created_d1: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        created_d2: Annotated[
            Optional[datetime],
            Field(description="Must be created at or before this time"),
        ] = None,
        created_on: Annotated[
            Optional[date], Field(description="Must be created on this date")
        ] = None,
        observed_on: Annotated[
            Optional[date], Field(description="Must be observed on this date")
        ] = None,
        unobserved_by_user_id: Annotated[
            Optional[StrictInt],
            Field(
                description="Must not be of a taxon previously observed by this user"
            ),
        ] = None,
        apply_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must match the rules of the project with this ID or slug"
            ),
        ] = None,
        cs: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csa: Annotated[
            Optional[StrictStr],
            Field(
                description="Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        csi: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place "
            ),
        ] = None,
        geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(description="Must have this geoprivacy setting"),
        ] = None,
        taxon_geoprivacy: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications. "
            ),
        ] = None,
        obscuration: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values "
            ),
        ] = None,
        hrank: Annotated[
            Optional[StrictStr], Field(description="Taxon must have this rank or lower")
        ] = None,
        lrank: Annotated[
            Optional[StrictStr],
            Field(description="Taxon must have this rank or higher"),
        ] = None,
        iconic_taxa: Annotated[
            Optional[List[StrictStr]],
            Field(description="Taxon must by within this iconic taxon"),
        ] = None,
        id_above: Annotated[
            Optional[StrictStr], Field(description="Must have an ID above this value")
        ] = None,
        id_below: Annotated[
            Optional[StrictStr], Field(description="Must have an ID below this value")
        ] = None,
        identifications: Annotated[
            Optional[StrictStr],
            Field(description="Identifications must meet these criteria"),
        ] = None,
        lat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        lng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        radius: Annotated[
            Optional[StrictStr],
            Field(
                description="Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius) "
            ),
        ] = None,
        nelat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        nelng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlat: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        swlng: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Must be within this bounding box (*nelat, *nelng, *swlat, *swlng) "
            ),
        ] = None,
        list_id: Annotated[
            Optional[StrictInt],
            Field(description="Taxon must be in the list with this ID"),
        ] = None,
        not_in_project: Annotated[
            Optional[StrictStr],
            Field(description="Must not be in the project with this ID or slug"),
        ] = None,
        not_matching_project_rules_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Must not match the rules of the project with this ID or slug"
            ),
        ] = None,
        observation_accuracy_experiment_id: Annotated[
            Optional[List[StrictInt]],
            Field(description="Must included in this observation accuracy experiment"),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Search observation properties. Can be combined with `search_on`"
            ),
        ] = None,
        search_on: Annotated[
            Optional[StrictStr],
            Field(
                description="Properties to search on, when combined with `q`. Searches across all properties by default "
            ),
        ] = None,
        quality_grade: Annotated[
            Optional[StrictStr], Field(description="Must have this quality grade")
        ] = None,
        updated_since: Annotated[
            Optional[StrictStr], Field(description="Must be updated since this time")
        ] = None,
        viewer_id: Annotated[
            Optional[StrictStr], Field(description="See `reviewed`")
        ] = None,
        reviewed: Annotated[
            Optional[StrictBool],
            Field(
                description="Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter "
            ),
        ] = None,
        locale: Annotated[
            Optional[StrictStr],
            Field(description="Locale preference for taxon common names "),
        ] = None,
        preferred_place_id: Annotated[
            Optional[StrictInt],
            Field(description="Place preference for regional taxon common names "),
        ] = None,
        ttl: Annotated[
            Optional[StrictStr],
            Field(
                description="Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers "
            ),
        ] = None,
        include_ancestors: Annotated[
            Optional[StrictBool],
            Field(description="Include taxon ancestors in the response"),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is 500 "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Species Counts

        Given zero to many of following parameters, returns `leaf taxa` associated with observations matching the search criteria and the count of observations they are associated with, ordered by count descending. `Leaf taxa` are the leaves of the taxonomic tree containing only the taxa associated with observations matching the search criteria.

        :param acc: Whether or not positional accuracy / coordinate uncertainty has been specified
        :type acc: bool
        :param captive: Captive or cultivated observations
        :type captive: bool
        :param endemic: Observations whose taxa are endemic to their location
        :type endemic: bool
        :param geo: Observations that are georeferenced
        :type geo: bool
        :param id_please: Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
        :type id_please: bool
        :param identified: Observations that have community identifications
        :type identified: bool
        :param introduced: Observations whose taxa are introduced in their location
        :type introduced: bool
        :param mappable: Observations that show on map tiles
        :type mappable: bool
        :param native: Observations whose taxa are native to their location
        :type native: bool
        :param out_of_range: Observations whose taxa are outside their known ranges
        :type out_of_range: bool
        :param pcid: Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        :type pcid: bool
        :param photos: Observations with photos
        :type photos: bool
        :param popular: Observations that have been favorited by at least one user
        :type popular: bool
        :param sounds: Observations with sounds
        :type sounds: bool
        :param taxon_is_active: Observations of active taxon concepts
        :type taxon_is_active: bool
        :param threatened: Observations whose taxa are threatened in their location
        :type threatened: bool
        :param verifiable: Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
        :type verifiable: bool
        :param licensed: License attribute of an observation must not be null
        :type licensed: bool
        :param photo_licensed: License attribute of at least one photo of an observation must not be null
        :type photo_licensed: bool
        :param expected_nearby: Observation taxon is expected nearby
        :type expected_nearby: bool
        :param id: Must have this ID
        :type id: List[str]
        :param not_id: Must not have this ID
        :type not_id: List[str]
        :param license: Observation must have this license
        :type license: List[str]
        :param ofv_datatype: Must have an observation field value with this datatype
        :type ofv_datatype: List[str]
        :param photo_license: Must have at least one photo with this license
        :type photo_license: List[str]
        :param place_id: Must be observed within the place with this ID
        :type place_id: List[int]
        :param project_id: Must be added to the project this ID or slug
        :type project_id: List[str]
        :param rank: Taxon must have this rank
        :type rank: List[str]
        :param site_id: Must be affiliated with the iNaturalist network website with this ID
        :type site_id: List[str]
        :param sound_license: Must have at least one sound with this license
        :type sound_license: List[str]
        :param taxon_id: Only show observations of these taxa and their descendants
        :type taxon_id: List[str]
        :param without_taxon_id: Exclude observations of these taxa and their descendants
        :type without_taxon_id: List[str]
        :param taxon_name: Taxon must have a scientific or common name matching this string
        :type taxon_name: List[str]
        :param user_id: User must have this ID or login
        :type user_id: List[str]
        :param user_login: User must have this login
        :type user_login: List[str]
        :param ident_user_id: Observations identified by a particular user
        :type ident_user_id: int
        :param hour: Must be observed within this hour of the day
        :type hour: List[str]
        :param day: Must be observed within this day of the month
        :type day: List[str]
        :param month: Must be observed within this month
        :type month: List[str]
        :param year: Must be observed within this year
        :type year: List[str]
        :param created_day: Must be created within this day of the month
        :type created_day: List[str]
        :param created_month: Must be created within this month
        :type created_month: List[str]
        :param created_year: Must be created within this year
        :type created_year: List[str]
        :param term_id: Must have an annotation using this controlled term ID
        :type term_id: List[int]
        :param term_value_id: Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
        :type term_value_id: List[int]
        :param without_term_id: Exclude observations with annotations using this controlled value ID.
        :type without_term_id: int
        :param without_term_value_id: Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
        :type without_term_value_id: List[int]
        :param term_id_or_unknown: Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
        :type term_id_or_unknown: List[int]
        :param annotation_user_id: Must have an annotation created by this user
        :type annotation_user_id: List[str]
        :param acc_above: Must have a positional accuracy above this value (meters)
        :type acc_above: str
        :param acc_below: Must have a positional accuracy below this value (meters)
        :type acc_below: str
        :param acc_below_or_unknown: Positional accuracy must be below this value (in meters) or be unknown
        :type acc_below_or_unknown: str
        :param d1: Must be observed on or after this date
        :type d1: date
        :param d2: Must be observed on or before this date
        :type d2: date
        :param created_d1: Must be created at or after this time
        :type created_d1: datetime
        :param created_d2: Must be created at or before this time
        :type created_d2: datetime
        :param created_on: Must be created on this date
        :type created_on: date
        :param observed_on: Must be observed on this date
        :type observed_on: date
        :param unobserved_by_user_id: Must not be of a taxon previously observed by this user
        :type unobserved_by_user_id: int
        :param apply_project_rules_for: Must match the rules of the project with this ID or slug
        :type apply_project_rules_for: str
        :param cs: Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type cs: str
        :param csa: Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csa: str
        :param csi: Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
        :type csi: List[str]
        :param geoprivacy: Must have this geoprivacy setting
        :type geoprivacy: List[str]
        :param taxon_geoprivacy: Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        :type taxon_geoprivacy: List[str]
        :param obscuration: Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
        :type obscuration: List[str]
        :param hrank: Taxon must have this rank or lower
        :type hrank: str
        :param lrank: Taxon must have this rank or higher
        :type lrank: str
        :param iconic_taxa: Taxon must by within this iconic taxon
        :type iconic_taxa: List[str]
        :param id_above: Must have an ID above this value
        :type id_above: str
        :param id_below: Must have an ID below this value
        :type id_below: str
        :param identifications: Identifications must meet these criteria
        :type identifications: str
        :param lat: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lat: float
        :param lng: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type lng: float
        :param radius: Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
        :type radius: str
        :param nelat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelat: float
        :param nelng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type nelng: float
        :param swlat: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlat: float
        :param swlng: Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
        :type swlng: float
        :param list_id: Taxon must be in the list with this ID
        :type list_id: int
        :param not_in_project: Must not be in the project with this ID or slug
        :type not_in_project: str
        :param not_matching_project_rules_for: Must not match the rules of the project with this ID or slug
        :type not_matching_project_rules_for: str
        :param observation_accuracy_experiment_id: Must included in this observation accuracy experiment
        :type observation_accuracy_experiment_id: List[int]
        :param q: Search observation properties. Can be combined with `search_on`
        :type q: str
        :param search_on: Properties to search on, when combined with `q`. Searches across all properties by default
        :type search_on: str
        :param quality_grade: Must have this quality grade
        :type quality_grade: str
        :param updated_since: Must be updated since this time
        :type updated_since: str
        :param viewer_id: See `reviewed`
        :type viewer_id: str
        :param reviewed: Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
        :type reviewed: bool
        :param locale: Locale preference for taxon common names
        :type locale: str
        :param preferred_place_id: Place preference for regional taxon common names
        :type preferred_place_id: int
        :param ttl: Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        :type ttl: str
        :param include_ancestors: Include taxon ancestors in the response
        :type include_ancestors: bool
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is 500
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_species_counts_get_serialize(
            acc=acc,
            captive=captive,
            endemic=endemic,
            geo=geo,
            id_please=id_please,
            identified=identified,
            introduced=introduced,
            mappable=mappable,
            native=native,
            out_of_range=out_of_range,
            pcid=pcid,
            photos=photos,
            popular=popular,
            sounds=sounds,
            taxon_is_active=taxon_is_active,
            threatened=threatened,
            verifiable=verifiable,
            licensed=licensed,
            photo_licensed=photo_licensed,
            expected_nearby=expected_nearby,
            id=id,
            not_id=not_id,
            license=license,
            ofv_datatype=ofv_datatype,
            photo_license=photo_license,
            place_id=place_id,
            project_id=project_id,
            rank=rank,
            site_id=site_id,
            sound_license=sound_license,
            taxon_id=taxon_id,
            without_taxon_id=without_taxon_id,
            taxon_name=taxon_name,
            user_id=user_id,
            user_login=user_login,
            ident_user_id=ident_user_id,
            hour=hour,
            day=day,
            month=month,
            year=year,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            term_id=term_id,
            term_value_id=term_value_id,
            without_term_id=without_term_id,
            without_term_value_id=without_term_value_id,
            term_id_or_unknown=term_id_or_unknown,
            annotation_user_id=annotation_user_id,
            acc_above=acc_above,
            acc_below=acc_below,
            acc_below_or_unknown=acc_below_or_unknown,
            d1=d1,
            d2=d2,
            created_d1=created_d1,
            created_d2=created_d2,
            created_on=created_on,
            observed_on=observed_on,
            unobserved_by_user_id=unobserved_by_user_id,
            apply_project_rules_for=apply_project_rules_for,
            cs=cs,
            csa=csa,
            csi=csi,
            geoprivacy=geoprivacy,
            taxon_geoprivacy=taxon_geoprivacy,
            obscuration=obscuration,
            hrank=hrank,
            lrank=lrank,
            iconic_taxa=iconic_taxa,
            id_above=id_above,
            id_below=id_below,
            identifications=identifications,
            lat=lat,
            lng=lng,
            radius=radius,
            nelat=nelat,
            nelng=nelng,
            swlat=swlat,
            swlng=swlng,
            list_id=list_id,
            not_in_project=not_in_project,
            not_matching_project_rules_for=not_matching_project_rules_for,
            observation_accuracy_experiment_id=observation_accuracy_experiment_id,
            q=q,
            search_on=search_on,
            quality_grade=quality_grade,
            updated_since=updated_since,
            viewer_id=viewer_id,
            reviewed=reviewed,
            locale=locale,
            preferred_place_id=preferred_place_id,
            ttl=ttl,
            include_ancestors=include_ancestors,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SpeciesCountsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_species_counts_get_serialize(
        self,
        acc,
        captive,
        endemic,
        geo,
        id_please,
        identified,
        introduced,
        mappable,
        native,
        out_of_range,
        pcid,
        photos,
        popular,
        sounds,
        taxon_is_active,
        threatened,
        verifiable,
        licensed,
        photo_licensed,
        expected_nearby,
        id,
        not_id,
        license,
        ofv_datatype,
        photo_license,
        place_id,
        project_id,
        rank,
        site_id,
        sound_license,
        taxon_id,
        without_taxon_id,
        taxon_name,
        user_id,
        user_login,
        ident_user_id,
        hour,
        day,
        month,
        year,
        created_day,
        created_month,
        created_year,
        term_id,
        term_value_id,
        without_term_id,
        without_term_value_id,
        term_id_or_unknown,
        annotation_user_id,
        acc_above,
        acc_below,
        acc_below_or_unknown,
        d1,
        d2,
        created_d1,
        created_d2,
        created_on,
        observed_on,
        unobserved_by_user_id,
        apply_project_rules_for,
        cs,
        csa,
        csi,
        geoprivacy,
        taxon_geoprivacy,
        obscuration,
        hrank,
        lrank,
        iconic_taxa,
        id_above,
        id_below,
        identifications,
        lat,
        lng,
        radius,
        nelat,
        nelng,
        swlat,
        swlng,
        list_id,
        not_in_project,
        not_matching_project_rules_for,
        observation_accuracy_experiment_id,
        q,
        search_on,
        quality_grade,
        updated_since,
        viewer_id,
        reviewed,
        locale,
        preferred_place_id,
        ttl,
        include_ancestors,
        page,
        per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            "id": "csv",
            "not_id": "csv",
            "license": "csv",
            "ofv_datatype": "csv",
            "photo_license": "csv",
            "place_id": "csv",
            "project_id": "csv",
            "rank": "csv",
            "site_id": "csv",
            "sound_license": "csv",
            "taxon_id": "csv",
            "without_taxon_id": "csv",
            "taxon_name": "csv",
            "user_id": "csv",
            "user_login": "csv",
            "hour": "csv",
            "day": "csv",
            "month": "csv",
            "year": "csv",
            "created_day": "csv",
            "created_month": "csv",
            "created_year": "csv",
            "term_id": "csv",
            "term_value_id": "csv",
            "without_term_value_id": "csv",
            "term_id_or_unknown": "csv",
            "annotation_user_id": "csv",
            "csi": "csv",
            "geoprivacy": "csv",
            "taxon_geoprivacy": "csv",
            "obscuration": "csv",
            "iconic_taxa": "csv",
            "observation_accuracy_experiment_id": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if acc is not None:
            _query_params.append(("acc", acc))

        if captive is not None:
            _query_params.append(("captive", captive))

        if endemic is not None:
            _query_params.append(("endemic", endemic))

        if geo is not None:
            _query_params.append(("geo", geo))

        if id_please is not None:
            _query_params.append(("id_please", id_please))

        if identified is not None:
            _query_params.append(("identified", identified))

        if introduced is not None:
            _query_params.append(("introduced", introduced))

        if mappable is not None:
            _query_params.append(("mappable", mappable))

        if native is not None:
            _query_params.append(("native", native))

        if out_of_range is not None:
            _query_params.append(("out_of_range", out_of_range))

        if pcid is not None:
            _query_params.append(("pcid", pcid))

        if photos is not None:
            _query_params.append(("photos", photos))

        if popular is not None:
            _query_params.append(("popular", popular))

        if sounds is not None:
            _query_params.append(("sounds", sounds))

        if taxon_is_active is not None:
            _query_params.append(("taxon_is_active", taxon_is_active))

        if threatened is not None:
            _query_params.append(("threatened", threatened))

        if verifiable is not None:
            _query_params.append(("verifiable", verifiable))

        if licensed is not None:
            _query_params.append(("licensed", licensed))

        if photo_licensed is not None:
            _query_params.append(("photo_licensed", photo_licensed))

        if expected_nearby is not None:
            _query_params.append(("expected_nearby", expected_nearby))

        if id is not None:
            _query_params.append(("id", id))

        if not_id is not None:
            _query_params.append(("not_id", not_id))

        if license is not None:
            _query_params.append(("license", license))

        if ofv_datatype is not None:
            _query_params.append(("ofv_datatype", ofv_datatype))

        if photo_license is not None:
            _query_params.append(("photo_license", photo_license))

        if place_id is not None:
            _query_params.append(("place_id", place_id))

        if project_id is not None:
            _query_params.append(("project_id", project_id))

        if rank is not None:
            _query_params.append(("rank", rank))

        if site_id is not None:
            _query_params.append(("site_id", site_id))

        if sound_license is not None:
            _query_params.append(("sound_license", sound_license))

        if taxon_id is not None:
            _query_params.append(("taxon_id", taxon_id))

        if without_taxon_id is not None:
            _query_params.append(("without_taxon_id", without_taxon_id))

        if taxon_name is not None:
            _query_params.append(("taxon_name", taxon_name))

        if user_id is not None:
            _query_params.append(("user_id", user_id))

        if user_login is not None:
            _query_params.append(("user_login", user_login))

        if ident_user_id is not None:
            _query_params.append(("ident_user_id", ident_user_id))

        if hour is not None:
            _query_params.append(("hour", hour))

        if day is not None:
            _query_params.append(("day", day))

        if month is not None:
            _query_params.append(("month", month))

        if year is not None:
            _query_params.append(("year", year))

        if created_day is not None:
            _query_params.append(("created_day", created_day))

        if created_month is not None:
            _query_params.append(("created_month", created_month))

        if created_year is not None:
            _query_params.append(("created_year", created_year))

        if term_id is not None:
            _query_params.append(("term_id", term_id))

        if term_value_id is not None:
            _query_params.append(("term_value_id", term_value_id))

        if without_term_id is not None:
            _query_params.append(("without_term_id", without_term_id))

        if without_term_value_id is not None:
            _query_params.append(("without_term_value_id", without_term_value_id))

        if term_id_or_unknown is not None:
            _query_params.append(("term_id_or_unknown", term_id_or_unknown))

        if annotation_user_id is not None:
            _query_params.append(("annotation_user_id", annotation_user_id))

        if acc_above is not None:
            _query_params.append(("acc_above", acc_above))

        if acc_below is not None:
            _query_params.append(("acc_below", acc_below))

        if acc_below_or_unknown is not None:
            _query_params.append(("acc_below_or_unknown", acc_below_or_unknown))

        if d1 is not None:
            if isinstance(d1, date):
                _query_params.append(
                    ("d1", d1.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d1", d1))

        if d2 is not None:
            if isinstance(d2, date):
                _query_params.append(
                    ("d2", d2.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(("d2", d2))

        if created_d1 is not None:
            if isinstance(created_d1, datetime):
                _query_params.append(
                    (
                        "created_d1",
                        created_d1.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d1", created_d1))

        if created_d2 is not None:
            if isinstance(created_d2, datetime):
                _query_params.append(
                    (
                        "created_d2",
                        created_d2.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_d2", created_d2))

        if created_on is not None:
            if isinstance(created_on, date):
                _query_params.append(
                    (
                        "created_on",
                        created_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("created_on", created_on))

        if observed_on is not None:
            if isinstance(observed_on, date):
                _query_params.append(
                    (
                        "observed_on",
                        observed_on.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(("observed_on", observed_on))

        if unobserved_by_user_id is not None:
            _query_params.append(("unobserved_by_user_id", unobserved_by_user_id))

        if apply_project_rules_for is not None:
            _query_params.append(("apply_project_rules_for", apply_project_rules_for))

        if cs is not None:
            _query_params.append(("cs", cs))

        if csa is not None:
            _query_params.append(("csa", csa))

        if csi is not None:
            _query_params.append(("csi", csi))

        if geoprivacy is not None:
            _query_params.append(("geoprivacy", geoprivacy))

        if taxon_geoprivacy is not None:
            _query_params.append(("taxon_geoprivacy", taxon_geoprivacy))

        if obscuration is not None:
            _query_params.append(("obscuration", obscuration))

        if hrank is not None:
            _query_params.append(("hrank", hrank))

        if lrank is not None:
            _query_params.append(("lrank", lrank))

        if iconic_taxa is not None:
            _query_params.append(("iconic_taxa", iconic_taxa))

        if id_above is not None:
            _query_params.append(("id_above", id_above))

        if id_below is not None:
            _query_params.append(("id_below", id_below))

        if identifications is not None:
            _query_params.append(("identifications", identifications))

        if lat is not None:
            _query_params.append(("lat", lat))

        if lng is not None:
            _query_params.append(("lng", lng))

        if radius is not None:
            _query_params.append(("radius", radius))

        if nelat is not None:
            _query_params.append(("nelat", nelat))

        if nelng is not None:
            _query_params.append(("nelng", nelng))

        if swlat is not None:
            _query_params.append(("swlat", swlat))

        if swlng is not None:
            _query_params.append(("swlng", swlng))

        if list_id is not None:
            _query_params.append(("list_id", list_id))

        if not_in_project is not None:
            _query_params.append(("not_in_project", not_in_project))

        if not_matching_project_rules_for is not None:
            _query_params.append(
                ("not_matching_project_rules_for", not_matching_project_rules_for)
            )

        if observation_accuracy_experiment_id is not None:
            _query_params.append(
                (
                    "observation_accuracy_experiment_id",
                    observation_accuracy_experiment_id,
                )
            )

        if q is not None:
            _query_params.append(("q", q))

        if search_on is not None:
            _query_params.append(("search_on", search_on))

        if quality_grade is not None:
            _query_params.append(("quality_grade", quality_grade))

        if updated_since is not None:
            _query_params.append(("updated_since", updated_since))

        if viewer_id is not None:
            _query_params.append(("viewer_id", viewer_id))

        if reviewed is not None:
            _query_params.append(("reviewed", reviewed))

        if locale is not None:
            _query_params.append(("locale", locale))

        if preferred_place_id is not None:
            _query_params.append(("preferred_place_id", preferred_place_id))

        if ttl is not None:
            _query_params.append(("ttl", ttl))

        if include_ancestors is not None:
            _query_params.append(("include_ancestors", include_ancestors))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/species_counts",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def observations_updates_get(
        self,
        created_after: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        viewed: Annotated[
            Optional[StrictBool],
            Field(description="Notification has been viewed by the user before"),
        ] = None,
        observations_by: Annotated[
            Optional[StrictStr],
            Field(
                description="Only show updates on observations owned by the currently authenticated user or on observations the authenticated user is following but does not own. "
            ),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation User Updates

        Given zero to many of following parameters, returns an array of objects representing new comments and identifications on observations the authenticated user has subscribed to. Requires authentication

        :param created_after: Must be created at or after this time
        :type created_after: datetime
        :param viewed: Notification has been viewed by the user before
        :type viewed: bool
        :param observations_by: Only show updates on observations owned by the currently authenticated user or on observations the authenticated user is following but does not own.
        :type observations_by: str
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_updates_get_serialize(
            created_after=created_after,
            viewed=viewed,
            observations_by=observations_by,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def observations_updates_get_with_http_info(
        self,
        created_after: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        viewed: Annotated[
            Optional[StrictBool],
            Field(description="Notification has been viewed by the user before"),
        ] = None,
        observations_by: Annotated[
            Optional[StrictStr],
            Field(
                description="Only show updates on observations owned by the currently authenticated user or on observations the authenticated user is following but does not own. "
            ),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation User Updates

        Given zero to many of following parameters, returns an array of objects representing new comments and identifications on observations the authenticated user has subscribed to. Requires authentication

        :param created_after: Must be created at or after this time
        :type created_after: datetime
        :param viewed: Notification has been viewed by the user before
        :type viewed: bool
        :param observations_by: Only show updates on observations owned by the currently authenticated user or on observations the authenticated user is following but does not own.
        :type observations_by: str
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_updates_get_serialize(
            created_after=created_after,
            viewed=viewed,
            observations_by=observations_by,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def observations_updates_get_without_preload_content(
        self,
        created_after: Annotated[
            Optional[datetime],
            Field(description="Must be created at or after this time"),
        ] = None,
        viewed: Annotated[
            Optional[StrictBool],
            Field(description="Notification has been viewed by the user before"),
        ] = None,
        observations_by: Annotated[
            Optional[StrictStr],
            Field(
                description="Only show updates on observations owned by the currently authenticated user or on observations the authenticated user is following but does not own. "
            ),
        ] = None,
        page: Annotated[
            Optional[StrictStr], Field(description="Pagination `page` number")
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation User Updates

        Given zero to many of following parameters, returns an array of objects representing new comments and identifications on observations the authenticated user has subscribed to. Requires authentication

        :param created_after: Must be created at or after this time
        :type created_after: datetime
        :param viewed: Notification has been viewed by the user before
        :type viewed: bool
        :param observations_by: Only show updates on observations owned by the currently authenticated user or on observations the authenticated user is following but does not own.
        :type observations_by: str
        :param page: Pagination `page` number
        :type page: str
        :param per_page: Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._observations_updates_get_serialize(
            created_after=created_after,
            viewed=viewed,
            observations_by=observations_by,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _observations_updates_get_serialize(
        self,
        created_after,
        viewed,
        observations_by,
        page,
        per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if created_after is not None:
            if isinstance(created_after, datetime):
                _query_params.append(
                    (
                        "created_after",
                        created_after.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_after", created_after))

        if viewed is not None:
            _query_params.append(("viewed", viewed))

        if observations_by is not None:
            _query_params.append(("observations_by", observations_by))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/observations/updates",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def subscriptions_observation_id_subscribe_post(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Subscribe

        Toggles current user's subscription to this observation. If the logged-in user is not subscribed, POSTing here will subscribe them. If they are already subscribed, this will remove the subscription

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._subscriptions_observation_id_subscribe_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def subscriptions_observation_id_subscribe_post_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Subscribe

        Toggles current user's subscription to this observation. If the logged-in user is not subscribed, POSTing here will subscribe them. If they are already subscribed, this will remove the subscription

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._subscriptions_observation_id_subscribe_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def subscriptions_observation_id_subscribe_post_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Subscribe

        Toggles current user's subscription to this observation. If the logged-in user is not subscribed, POSTing here will subscribe them. If they are already subscribed, this will remove the subscription

        :param id: ID of the record (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._subscriptions_observation_id_subscribe_post_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _subscriptions_observation_id_subscribe_post_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/subscriptions/observation/{id}/subscribe",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def votes_unvote_observation_id_delete(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostObservationVote], Field(description="Vote object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Unvote

        Remove a vote from an observation

        :param id: ID of the record (required)
        :type id: int
        :param body: Vote object
        :type body: PostObservationVote
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._votes_unvote_observation_id_delete_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def votes_unvote_observation_id_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostObservationVote], Field(description="Vote object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Unvote

        Remove a vote from an observation

        :param id: ID of the record (required)
        :type id: int
        :param body: Vote object
        :type body: PostObservationVote
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._votes_unvote_observation_id_delete_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def votes_unvote_observation_id_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostObservationVote], Field(description="Vote object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Unvote

        Remove a vote from an observation

        :param id: ID of the record (required)
        :type id: int
        :param body: Vote object
        :type body: PostObservationVote
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._votes_unvote_observation_id_delete_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _votes_unvote_observation_id_delete_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/votes/unvote/observation/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def votes_vote_observation_id_post(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostObservationVote], Field(description="Vote object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Observation Vote

        Vote on an observation. A vote with an empty `scope` is recorded as a `fave` of the observation. A vote with scope `needs_id` is recorded as a vote on the Quality Grade criterion \"can the Community ID still be confirmed or improved?\", and can be an up or down vote

        :param id: ID of the record (required)
        :type id: int
        :param body: Vote object
        :type body: PostObservationVote
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._votes_vote_observation_id_post_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def votes_vote_observation_id_post_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostObservationVote], Field(description="Vote object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Observation Vote

        Vote on an observation. A vote with an empty `scope` is recorded as a `fave` of the observation. A vote with scope `needs_id` is recorded as a vote on the Quality Grade criterion \"can the Community ID still be confirmed or improved?\", and can be an up or down vote

        :param id: ID of the record (required)
        :type id: int
        :param body: Vote object
        :type body: PostObservationVote
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._votes_vote_observation_id_post_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def votes_vote_observation_id_post_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID of the record")],
        body: Annotated[
            Optional[PostObservationVote], Field(description="Vote object")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Observation Vote

        Vote on an observation. A vote with an empty `scope` is recorded as a `fave` of the observation. A vote with scope `needs_id` is recorded as a vote on the Quality Grade criterion \"can the Community ID still be confirmed or improved?\", and can be an up or down vote

        :param id: ID of the record (required)
        :type id: int
        :param body: Vote object
        :type body: PostObservationVote
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._votes_vote_observation_id_post_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _votes_vote_observation_id_post_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # authentication setting
        _auth_settings: List[str] = ["api_token"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/votes/vote/observation/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
