# coding: utf-8

"""
iNaturalist API

# https://api.inaturalist.org/v1/  [iNaturalist](https://www.inaturalist.org/) is a global community of naturalists, scientists, and members of the public sharing over a million wildlife sightings to teach one another about the natural world while creating high quality citizen science data for science and conservation.  These API methods return data in JSON/JSONP and PNG response formats. They are meant to supplement the existing [iNaturalist API](https://www.inaturalist.org/pages/api+reference), implemented in Ruby on Rails, which has more functionality and supports more write operations, but tends to be slower and have less consistent response formats. Visit our [developers page](https://www.inaturalist.org/pages/developers) for more information. Write operations that expect and return JSON describe a single `body` parameter that represents the request body, which should be specified as JSON. See the \"Model\" of each body parameter for attributes that we accept in these JSON objects.  Multiple values for a single URL parameter should be separated by commas, e.g. `taxon_id=1,2,3`.  Map tiles are generated using the [node-mapnik](https://github.com/mapnik/node-mapnik) library, following the XYZ map tiling scheme. The \"Observation Tile\" methods accept nearly all the parameters of the observation search APIs, and will generate map tiles reflecting the same observations returned by searches. These \"Observation Tile\" methods have corresponding [UTFGrid](https://github.com/mapbox/utfgrid-spec) JSON responses which return information needed to make interactive maps.  Authentication in the Node API is handled via JSON Web Tokens (JWT). To obtain one, make an [OAuth-authenticated request](http://www.inaturalist.org/pages/api+reference#auth) to https://www.inaturalist.org/users/api_token. Each JWT will expire after 24 hours. Authentication required for all PUT and POST requests. Some GET requests will also include private information like hidden coordinates if the authenticated user has permission to view them.  Photos served from https://static.inaturalist.org and https://inaturalist-open-data.s3.amazonaws.com have multiple size variants and not all size variants are returned in responses. To access other sizes, the photo URL can be modified to replace only the size qualifier (each variant shares the exact same extension). The domain a photo is hosted under reflects the license under which the photo is being shared, and the domain may change over time if the license changes. Photos in the `inaturalist-open-data` domain are shared under open licenses. These can be accessed in bulk in the [iNaturalist AWS Open Dataset]( https://registry.opendata.aws/inaturalist-open-data/). Photos in the `static.inaturalist.org` domain do not have open licenses.  The available photo sizes are: * original (max 2048px in either dimension) * large (max 1024px in either dimension) * medium (max 500px in either dimension) * small (max 240px in either dimension) * thumb (max 100px in either dimension) * square (75px square)  iNaturalist Website: https://www.inaturalist.org/  Open Source Software: https://github.com/inaturalist/  ## Terms of Use  Use of this API is subject to the iNaturalist [Terms of Service](https://www.inaturalist.org/terms) and [Privacy Policy](https://www.inaturalist.org/privacy). We will block any use of our API that violates our Terms or Privacy Policy without notice. The API is intended to support application development, not data scraping. For pre- generated data exports, see https://www.inaturalist.org/pages/developers.  Please note that we throttle API usage to a max of 100 requests per minute, though we ask that you try to keep it to 60 requests per minute or lower, and to keep under 10,000 requests per day. If we notice usage that has serious impact on our performance we may institute blocks without notification.  Terms of Service: https://www.inaturalist.org/terms  Privacy Policy: https://www.inaturalist.org/privacy

The version of the OpenAPI document: 1.3.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from datetime import datetime
from typing import Any, ClassVar, Dict, List, Optional, Set

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing_extensions import Self

from inaturalist_client.models.comment import Comment
from inaturalist_client.models.date_details import DateDetails
from inaturalist_client.models.field_value import FieldValue
from inaturalist_client.models.non_owner_identification import NonOwnerIdentification
from inaturalist_client.models.observation_taxon import ObservationTaxon
from inaturalist_client.models.photo import Photo
from inaturalist_client.models.point_geo_json import PointGeoJson
from inaturalist_client.models.sound import Sound
from inaturalist_client.models.user import User


class Observation(BaseModel):
    """
    Observation
    """  # noqa: E501

    id: Optional[StrictInt] = None
    cached_votes_total: Optional[StrictInt] = None
    captive: Optional[StrictBool] = None
    comments: Optional[List[Comment]] = None
    comments_count: Optional[StrictInt] = None
    created_at: Optional[datetime] = None
    created_at_details: Optional[DateDetails] = None
    created_time_zone: Optional[StrictStr] = None
    description: Optional[StrictStr] = None
    faves_count: Optional[StrictInt] = None
    geojson: Optional[PointGeoJson] = None
    geoprivacy: Optional[StrictStr] = None
    taxon_geoprivacy: Optional[StrictStr] = None
    id_please: Optional[StrictBool] = None
    identifications_count: Optional[StrictInt] = None
    identifications_most_agree: Optional[StrictBool] = None
    identifications_most_disagree: Optional[StrictBool] = None
    identifications_some_agree: Optional[StrictBool] = None
    license_code: Optional[StrictStr] = None
    location: Optional[StrictStr] = Field(
        default=None, description='in the format "lat,lng"'
    )
    mappable: Optional[StrictBool] = None
    non_owner_ids: Optional[List[NonOwnerIdentification]] = None
    num_identification_agreements: Optional[StrictInt] = None
    num_identification_disagreements: Optional[StrictInt] = None
    obscured: Optional[StrictBool] = None
    observed_on: Optional[datetime] = None
    observed_on_details: Optional[DateDetails] = None
    observed_on_string: Optional[StrictStr] = None
    observed_time_zone: Optional[StrictStr] = None
    ofvs: Optional[List[FieldValue]] = None
    out_of_range: Optional[StrictBool] = None
    photos: Optional[List[Photo]] = None
    place_guess: Optional[StrictStr] = None
    place_ids: Optional[List[StrictInt]] = None
    project_ids: Optional[List[StrictInt]] = None
    project_ids_with_curator_id: Optional[List[StrictInt]] = None
    project_ids_without_curator_id: Optional[List[StrictInt]] = None
    quality_grade: Optional[StrictStr] = None
    reviewed_by: Optional[List[StrictInt]] = None
    site_id: Optional[StrictInt] = None
    sounds: Optional[List[Sound]] = None
    species_guess: Optional[StrictStr] = None
    tags: Optional[List[StrictStr]] = None
    taxon: Optional[ObservationTaxon] = None
    time_observed_at: Optional[datetime] = None
    time_zone_offset: Optional[StrictStr] = None
    updated_at: Optional[datetime] = None
    uri: Optional[StrictStr] = None
    user: Optional[User] = None
    verifiable: Optional[StrictBool] = None
    __properties: ClassVar[List[str]] = [
        "id",
        "cached_votes_total",
        "captive",
        "comments",
        "comments_count",
        "created_at",
        "created_at_details",
        "created_time_zone",
        "description",
        "faves_count",
        "geojson",
        "geoprivacy",
        "taxon_geoprivacy",
        "id_please",
        "identifications_count",
        "identifications_most_agree",
        "identifications_most_disagree",
        "identifications_some_agree",
        "license_code",
        "location",
        "mappable",
        "non_owner_ids",
        "num_identification_agreements",
        "num_identification_disagreements",
        "obscured",
        "observed_on",
        "observed_on_details",
        "observed_on_string",
        "observed_time_zone",
        "ofvs",
        "out_of_range",
        "photos",
        "place_guess",
        "place_ids",
        "project_ids",
        "project_ids_with_curator_id",
        "project_ids_without_curator_id",
        "quality_grade",
        "reviewed_by",
        "site_id",
        "sounds",
        "species_guess",
        "tags",
        "taxon",
        "time_observed_at",
        "time_zone_offset",
        "updated_at",
        "uri",
        "user",
        "verifiable",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Observation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in comments (list)
        _items = []
        if self.comments:
            for _item_comments in self.comments:
                if _item_comments:
                    _items.append(_item_comments.to_dict())
            _dict["comments"] = _items
        # override the default output from pydantic by calling `to_dict()` of created_at_details
        if self.created_at_details:
            _dict["created_at_details"] = self.created_at_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of geojson
        if self.geojson:
            _dict["geojson"] = self.geojson.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in non_owner_ids (list)
        _items = []
        if self.non_owner_ids:
            for _item_non_owner_ids in self.non_owner_ids:
                if _item_non_owner_ids:
                    _items.append(_item_non_owner_ids.to_dict())
            _dict["non_owner_ids"] = _items
        # override the default output from pydantic by calling `to_dict()` of observed_on_details
        if self.observed_on_details:
            _dict["observed_on_details"] = self.observed_on_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in ofvs (list)
        _items = []
        if self.ofvs:
            for _item_ofvs in self.ofvs:
                if _item_ofvs:
                    _items.append(_item_ofvs.to_dict())
            _dict["ofvs"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in photos (list)
        _items = []
        if self.photos:
            for _item_photos in self.photos:
                if _item_photos:
                    _items.append(_item_photos.to_dict())
            _dict["photos"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in sounds (list)
        _items = []
        if self.sounds:
            for _item_sounds in self.sounds:
                if _item_sounds:
                    _items.append(_item_sounds.to_dict())
            _dict["sounds"] = _items
        # override the default output from pydantic by calling `to_dict()` of taxon
        if self.taxon:
            _dict["taxon"] = self.taxon.to_dict()
        # override the default output from pydantic by calling `to_dict()` of user
        if self.user:
            _dict["user"] = self.user.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Observation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "id": obj.get("id"),
                "cached_votes_total": obj.get("cached_votes_total"),
                "captive": obj.get("captive"),
                "comments": [Comment.from_dict(_item) for _item in obj["comments"]]
                if obj.get("comments") is not None
                else None,
                "comments_count": obj.get("comments_count"),
                "created_at": obj.get("created_at"),
                "created_at_details": DateDetails.from_dict(obj["created_at_details"])
                if obj.get("created_at_details") is not None
                else None,
                "created_time_zone": obj.get("created_time_zone"),
                "description": obj.get("description"),
                "faves_count": obj.get("faves_count"),
                "geojson": PointGeoJson.from_dict(obj["geojson"])
                if obj.get("geojson") is not None
                else None,
                "geoprivacy": obj.get("geoprivacy"),
                "taxon_geoprivacy": obj.get("taxon_geoprivacy"),
                "id_please": obj.get("id_please"),
                "identifications_count": obj.get("identifications_count"),
                "identifications_most_agree": obj.get("identifications_most_agree"),
                "identifications_most_disagree": obj.get(
                    "identifications_most_disagree"
                ),
                "identifications_some_agree": obj.get("identifications_some_agree"),
                "license_code": obj.get("license_code"),
                "location": obj.get("location"),
                "mappable": obj.get("mappable"),
                "non_owner_ids": [
                    NonOwnerIdentification.from_dict(_item)
                    for _item in obj["non_owner_ids"]
                ]
                if obj.get("non_owner_ids") is not None
                else None,
                "num_identification_agreements": obj.get(
                    "num_identification_agreements"
                ),
                "num_identification_disagreements": obj.get(
                    "num_identification_disagreements"
                ),
                "obscured": obj.get("obscured"),
                "observed_on": obj.get("observed_on"),
                "observed_on_details": DateDetails.from_dict(obj["observed_on_details"])
                if obj.get("observed_on_details") is not None
                else None,
                "observed_on_string": obj.get("observed_on_string"),
                "observed_time_zone": obj.get("observed_time_zone"),
                "ofvs": [FieldValue.from_dict(_item) for _item in obj["ofvs"]]
                if obj.get("ofvs") is not None
                else None,
                "out_of_range": obj.get("out_of_range"),
                "photos": [Photo.from_dict(_item) for _item in obj["photos"]]
                if obj.get("photos") is not None
                else None,
                "place_guess": obj.get("place_guess"),
                "place_ids": obj.get("place_ids"),
                "project_ids": obj.get("project_ids"),
                "project_ids_with_curator_id": obj.get("project_ids_with_curator_id"),
                "project_ids_without_curator_id": obj.get(
                    "project_ids_without_curator_id"
                ),
                "quality_grade": obj.get("quality_grade"),
                "reviewed_by": obj.get("reviewed_by"),
                "site_id": obj.get("site_id"),
                "sounds": [Sound.from_dict(_item) for _item in obj["sounds"]]
                if obj.get("sounds") is not None
                else None,
                "species_guess": obj.get("species_guess"),
                "tags": obj.get("tags"),
                "taxon": ObservationTaxon.from_dict(obj["taxon"])
                if obj.get("taxon") is not None
                else None,
                "time_observed_at": obj.get("time_observed_at"),
                "time_zone_offset": obj.get("time_zone_offset"),
                "updated_at": obj.get("updated_at"),
                "uri": obj.get("uri"),
                "user": User.from_dict(obj["user"])
                if obj.get("user") is not None
                else None,
                "verifiable": obj.get("verifiable"),
            }
        )
        return _obj
